/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "vpnservice_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_af_afi(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case AF_AFI_AFI_IP:return "AF_AFI_AFI_IP";
  case AF_AFI_AFI_IPV6:return "AF_AFI_AFI_IPV6";
  case AF_AFI_AFI_L2VPN:return "AF_AFI_AFI_L2VPN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_af_safi(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case AF_SAFI_SAFI_IPV4_LABELED_UNICAST:return "AF_SAFI_SAFI_IPV4_LABELED_UNICAST";
  case AF_SAFI_SAFI_MPLS_VPN:return "AF_SAFI_SAFI_MPLS_VPN";
  case AF_SAFI_SAFI_EVPN:return "AF_SAFI_SAFI_EVPN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_encap_type(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ENCAP_TYPE_L2TPV3_OVER_IP:return "ENCAP_TYPE_L2TPV3_OVER_IP";
  case ENCAP_TYPE_GRE:return "ENCAP_TYPE_GRE";
  case ENCAP_TYPE_IP_IN_IP:return "ENCAP_TYPE_IP_IN_IP";
  case ENCAP_TYPE_VXLAN:return "ENCAP_TYPE_VXLAN";
  case ENCAP_TYPE_MPLS:return "ENCAP_TYPE_MPLS";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_layer_type(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case LAYER_TYPE_LAYER_2:return "LAYER_TYPE_LAYER_2";
  case LAYER_TYPE_LAYER_3:return "LAYER_TYPE_LAYER_3";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_protocol_type(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PROTOCOL_TYPE_PROTOCOL_LU:return "PROTOCOL_TYPE_PROTOCOL_LU";
  case PROTOCOL_TYPE_PROTOCOL_L3VPN:return "PROTOCOL_TYPE_PROTOCOL_L3VPN";
  case PROTOCOL_TYPE_PROTOCOL_EVPN:return "PROTOCOL_TYPE_PROTOCOL_EVPN";
  case PROTOCOL_TYPE_PROTOCOL_ANY:return "PROTOCOL_TYPE_PROTOCOL_ANY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _UpdateProperties
{
  PROP_UPDATE_0,
  PROP_UPDATE_TYPE,
  PROP_UPDATE_RESERVED,
  PROP_UPDATE_PREFIXLEN,
  PROP_UPDATE_L3LABEL,
  PROP_UPDATE_L2LABEL,
  PROP_UPDATE_ETHTAG,
  PROP_UPDATE_ESI,
  PROP_UPDATE_MACADDRESS,
  PROP_UPDATE_RD,
  PROP_UPDATE_PREFIX,
  PROP_UPDATE_NEXTHOP,
  PROP_UPDATE_ROUTERMAC
};

/* reads a update object */
static gint32
update_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Update * this_object = UPDATE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->reserved, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_reserved = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->prefixlen, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefixlen = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l3label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l3label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l2label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l2label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->ethtag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ethtag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->esi != NULL)
          {
            g_free(this_object->esi);
            this_object->esi = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->esi, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_esi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->macaddress != NULL)
          {
            g_free(this_object->macaddress);
            this_object->macaddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->macaddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_macaddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->nexthop != NULL)
          {
            g_free(this_object->nexthop);
            this_object->nexthop = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nexthop, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nexthop = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRING)
        {
          if (this_object->routermac != NULL)
          {
            g_free(this_object->routermac);
            this_object->routermac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->routermac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_routermac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
update_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Update * this_object = UPDATE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Update", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "reserved", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->reserved, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefixlen", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->prefixlen, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l3label", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l3label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l2label", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l2label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ethtag", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->ethtag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "esi", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->esi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "macaddress", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->macaddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nexthop", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->nexthop, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "routermac", T_STRING, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->routermac, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
update_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Update *self = UPDATE (object);

  switch (property_id)
  {
    case PROP_UPDATE_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_UPDATE_RESERVED:
      self->reserved = g_value_get_int (value);
      self->__isset_reserved = TRUE;
      break;

    case PROP_UPDATE_PREFIXLEN:
      self->prefixlen = g_value_get_int (value);
      self->__isset_prefixlen = TRUE;
      break;

    case PROP_UPDATE_L3LABEL:
      self->l3label = g_value_get_int (value);
      self->__isset_l3label = TRUE;
      break;

    case PROP_UPDATE_L2LABEL:
      self->l2label = g_value_get_int (value);
      self->__isset_l2label = TRUE;
      break;

    case PROP_UPDATE_ETHTAG:
      self->ethtag = g_value_get_int (value);
      self->__isset_ethtag = TRUE;
      break;

    case PROP_UPDATE_ESI:
      if (self->esi != NULL)
        g_free (self->esi);
      self->esi = g_value_dup_string (value);
      self->__isset_esi = TRUE;
      break;

    case PROP_UPDATE_MACADDRESS:
      if (self->macaddress != NULL)
        g_free (self->macaddress);
      self->macaddress = g_value_dup_string (value);
      self->__isset_macaddress = TRUE;
      break;

    case PROP_UPDATE_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_UPDATE_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_UPDATE_NEXTHOP:
      if (self->nexthop != NULL)
        g_free (self->nexthop);
      self->nexthop = g_value_dup_string (value);
      self->__isset_nexthop = TRUE;
      break;

    case PROP_UPDATE_ROUTERMAC:
      if (self->routermac != NULL)
        g_free (self->routermac);
      self->routermac = g_value_dup_string (value);
      self->__isset_routermac = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
update_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Update *self = UPDATE (object);

  switch (property_id)
  {
    case PROP_UPDATE_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_UPDATE_RESERVED:
      g_value_set_int (value, self->reserved);
      break;

    case PROP_UPDATE_PREFIXLEN:
      g_value_set_int (value, self->prefixlen);
      break;

    case PROP_UPDATE_L3LABEL:
      g_value_set_int (value, self->l3label);
      break;

    case PROP_UPDATE_L2LABEL:
      g_value_set_int (value, self->l2label);
      break;

    case PROP_UPDATE_ETHTAG:
      g_value_set_int (value, self->ethtag);
      break;

    case PROP_UPDATE_ESI:
      g_value_set_string (value, self->esi);
      break;

    case PROP_UPDATE_MACADDRESS:
      g_value_set_string (value, self->macaddress);
      break;

    case PROP_UPDATE_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_UPDATE_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_UPDATE_NEXTHOP:
      g_value_set_string (value, self->nexthop);
      break;

    case PROP_UPDATE_ROUTERMAC:
      g_value_set_string (value, self->routermac);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
update_instance_init (Update * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->type = 0;
  object->__isset_type = FALSE;
  object->reserved = 0;
  object->__isset_reserved = FALSE;
  object->prefixlen = 0;
  object->__isset_prefixlen = FALSE;
  object->l3label = 0;
  object->__isset_l3label = FALSE;
  object->l2label = 0;
  object->__isset_l2label = FALSE;
  object->ethtag = 0;
  object->__isset_ethtag = FALSE;
  object->esi = NULL;
  object->__isset_esi = FALSE;
  object->macaddress = NULL;
  object->__isset_macaddress = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->nexthop = NULL;
  object->__isset_nexthop = FALSE;
  object->routermac = NULL;
  object->__isset_routermac = FALSE;
}

static void 
update_finalize (GObject *object)
{
  Update *tobject = UPDATE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->esi != NULL)
  {
    g_free(tobject->esi);
    tobject->esi = NULL;
  }
  if (tobject->macaddress != NULL)
  {
    g_free(tobject->macaddress);
    tobject->macaddress = NULL;
  }
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
  if (tobject->nexthop != NULL)
  {
    g_free(tobject->nexthop);
    tobject->nexthop = NULL;
  }
  if (tobject->routermac != NULL)
  {
    g_free(tobject->routermac);
    tobject->routermac = NULL;
  }
}

static void
update_class_init (UpdateClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = update_read;
  struct_class->write = update_write;

  gobject_class->finalize = update_finalize;
  gobject_class->get_property = update_get_property;
  gobject_class->set_property = update_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_RESERVED,
     g_param_spec_int ("reserved",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_PREFIXLEN,
     g_param_spec_int ("prefixlen",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_L3LABEL,
     g_param_spec_int ("l3label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_L2LABEL,
     g_param_spec_int ("l2label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_ETHTAG,
     g_param_spec_int ("ethtag",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_ESI,
     g_param_spec_string ("esi",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_MACADDRESS,
     g_param_spec_string ("macaddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_NEXTHOP,
     g_param_spec_string ("nexthop",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_UPDATE_ROUTERMAC,
     g_param_spec_string ("routermac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
update_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UpdateClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) update_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Update),
      0, /* n_preallocs */
      (GInstanceInitFunc) update_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UpdateType",
                                   &type_info, 0);
  }

  return type;
}

enum _RoutesProperties
{
  PROP_ROUTES_0,
  PROP_ROUTES_ERRCODE,
  PROP_ROUTES_UPDATES,
  PROP_ROUTES_MORE
};

/* reads a routes object */
static gint32
routes_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Routes * this_object = ROUTES(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->errcode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errcode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Update * _elem0 = NULL;
              if ( _elem0 != NULL)
              {
                g_object_unref (_elem0);
              }
              _elem0 = g_object_new (TYPE_UPDATE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem0), protocol, error)) < 0)
              {
                g_object_unref (_elem0);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->updates, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_updates = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->more, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_more = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
routes_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Routes * this_object = ROUTES(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Routes", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errcode", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->errcode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_updates == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updates", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i1;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->updates ? this_object->updates->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i1 = 0; i1 < (this_object->updates ? this_object->updates->len : 0); i1++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->updates, i1))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_more == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "more", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->more, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
routes_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Routes *self = ROUTES (object);

  switch (property_id)
  {
    case PROP_ROUTES_ERRCODE:
      self->errcode = g_value_get_int (value);
      self->__isset_errcode = TRUE;
      break;

    case PROP_ROUTES_UPDATES:
      if (self->updates != NULL)
        g_ptr_array_unref (self->updates);
      self->updates = g_value_dup_boxed (value);
      self->__isset_updates = TRUE;
      break;

    case PROP_ROUTES_MORE:
      self->more = g_value_get_int (value);
      self->__isset_more = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
routes_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Routes *self = ROUTES (object);

  switch (property_id)
  {
    case PROP_ROUTES_ERRCODE:
      g_value_set_int (value, self->errcode);
      break;

    case PROP_ROUTES_UPDATES:
      g_value_set_boxed (value, self->updates);
      break;

    case PROP_ROUTES_MORE:
      g_value_set_int (value, self->more);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
routes_instance_init (Routes * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->errcode = 0;
  object->__isset_errcode = FALSE;
  object->updates = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_updates = FALSE;
  object->more = 0;
  object->__isset_more = FALSE;
}

static void 
routes_finalize (GObject *object)
{
  Routes *tobject = ROUTES (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->updates != NULL)
  {
    g_ptr_array_unref (tobject->updates);
    tobject->updates = NULL;
  }
}

static void
routes_class_init (RoutesClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = routes_read;
  struct_class->write = routes_write;

  gobject_class->finalize = routes_finalize;
  gobject_class->get_property = routes_get_property;
  gobject_class->set_property = routes_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ROUTES_ERRCODE,
     g_param_spec_int ("errcode",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROUTES_UPDATES,
     g_param_spec_boxed ("updates",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROUTES_MORE,
     g_param_spec_int ("more",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
routes_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RoutesClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) routes_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Routes),
      0, /* n_preallocs */
      (GInstanceInitFunc) routes_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RoutesType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _BgpConfiguratorStartBgpArgsProperties
{
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_0,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_AS_NUMBER,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ROUTER_ID,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_PORT,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_HOLD_TIME,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_KEEP_ALIVE_TIME,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_STALEPATH_TIME,
  PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ANNOUNCE_FBIT
};

/* reads a bgp_configurator_start_bgp_args object */
static gint32
bgp_configurator_start_bgp_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorStartBgpArgs * this_object = BGP_CONFIGURATOR_START_BGP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->asNumber, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asNumber = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->routerId != NULL)
          {
            g_free(this_object->routerId);
            this_object->routerId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->routerId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_routerId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->port, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->holdTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_holdTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->keepAliveTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_keepAliveTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->stalepathTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stalepathTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->announceFbit, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_announceFbit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_start_bgp_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorStartBgpArgs * this_object = BGP_CONFIGURATOR_START_BGP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorStartBgpArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asNumber", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->asNumber, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "routerId", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->routerId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->port, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "holdTime", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->holdTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "keepAliveTime", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->keepAliveTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stalepathTime", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->stalepathTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "announceFbit", T_BOOL, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->announceFbit, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_start_bgp_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorStartBgpArgs *self = BGP_CONFIGURATOR_START_BGP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_AS_NUMBER:
      self->asNumber = g_value_get_int64 (value);
      self->__isset_asNumber = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ROUTER_ID:
      if (self->routerId != NULL)
        g_free (self->routerId);
      self->routerId = g_value_dup_string (value);
      self->__isset_routerId = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_PORT:
      self->port = g_value_get_int (value);
      self->__isset_port = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_HOLD_TIME:
      self->holdTime = g_value_get_int (value);
      self->__isset_holdTime = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_KEEP_ALIVE_TIME:
      self->keepAliveTime = g_value_get_int (value);
      self->__isset_keepAliveTime = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_STALEPATH_TIME:
      self->stalepathTime = g_value_get_int (value);
      self->__isset_stalepathTime = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ANNOUNCE_FBIT:
      self->announceFbit = g_value_get_boolean (value);
      self->__isset_announceFbit = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_start_bgp_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorStartBgpArgs *self = BGP_CONFIGURATOR_START_BGP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_AS_NUMBER:
      g_value_set_int64 (value, self->asNumber);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ROUTER_ID:
      g_value_set_string (value, self->routerId);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_PORT:
      g_value_set_int (value, self->port);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_HOLD_TIME:
      g_value_set_int (value, self->holdTime);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_KEEP_ALIVE_TIME:
      g_value_set_int (value, self->keepAliveTime);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_STALEPATH_TIME:
      g_value_set_int (value, self->stalepathTime);
      break;

    case PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ANNOUNCE_FBIT:
      g_value_set_boolean (value, self->announceFbit);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_start_bgp_args_instance_init (BgpConfiguratorStartBgpArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->asNumber = 0;
  object->__isset_asNumber = FALSE;
  object->routerId = NULL;
  object->__isset_routerId = FALSE;
  object->port = 0;
  object->__isset_port = FALSE;
  object->holdTime = 0;
  object->__isset_holdTime = FALSE;
  object->keepAliveTime = 0;
  object->__isset_keepAliveTime = FALSE;
  object->stalepathTime = 0;
  object->__isset_stalepathTime = FALSE;
  object->announceFbit = 0;
  object->__isset_announceFbit = FALSE;
}

static void 
bgp_configurator_start_bgp_args_finalize (GObject *object)
{
  BgpConfiguratorStartBgpArgs *tobject = BGP_CONFIGURATOR_START_BGP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->routerId != NULL)
  {
    g_free(tobject->routerId);
    tobject->routerId = NULL;
  }
}

static void
bgp_configurator_start_bgp_args_class_init (BgpConfiguratorStartBgpArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_start_bgp_args_read;
  struct_class->write = bgp_configurator_start_bgp_args_write;

  gobject_class->finalize = bgp_configurator_start_bgp_args_finalize;
  gobject_class->get_property = bgp_configurator_start_bgp_args_get_property;
  gobject_class->set_property = bgp_configurator_start_bgp_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_AS_NUMBER,
     g_param_spec_int64 ("asNumber",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ROUTER_ID,
     g_param_spec_string ("routerId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_PORT,
     g_param_spec_int ("port",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_HOLD_TIME,
     g_param_spec_int ("holdTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_KEEP_ALIVE_TIME,
     g_param_spec_int ("keepAliveTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_STALEPATH_TIME,
     g_param_spec_int ("stalepathTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_ARGS_ANNOUNCE_FBIT,
     g_param_spec_boolean ("announceFbit",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
bgp_configurator_start_bgp_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorStartBgpArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_start_bgp_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorStartBgpArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_start_bgp_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorStartBgpArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorStartBgpResultProperties
{
  PROP_BGP_CONFIGURATOR_START_BGP_RESULT_0,
  PROP_BGP_CONFIGURATOR_START_BGP_RESULT_SUCCESS
};

/* reads a bgp_configurator_start_bgp_result object */
static gint32
bgp_configurator_start_bgp_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorStartBgpResult * this_object = BGP_CONFIGURATOR_START_BGP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_start_bgp_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorStartBgpResult * this_object = BGP_CONFIGURATOR_START_BGP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorStartBgpResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_start_bgp_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorStartBgpResult *self = BGP_CONFIGURATOR_START_BGP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_START_BGP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_start_bgp_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorStartBgpResult *self = BGP_CONFIGURATOR_START_BGP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_START_BGP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_start_bgp_result_instance_init (BgpConfiguratorStartBgpResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_start_bgp_result_finalize (GObject *object)
{
  BgpConfiguratorStartBgpResult *tobject = BGP_CONFIGURATOR_START_BGP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_start_bgp_result_class_init (BgpConfiguratorStartBgpResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_start_bgp_result_read;
  struct_class->write = bgp_configurator_start_bgp_result_write;

  gobject_class->finalize = bgp_configurator_start_bgp_result_finalize;
  gobject_class->get_property = bgp_configurator_start_bgp_result_get_property;
  gobject_class->set_property = bgp_configurator_start_bgp_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_START_BGP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_start_bgp_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorStartBgpResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_start_bgp_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorStartBgpResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_start_bgp_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorStartBgpResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorStopBgpArgsProperties
{
  PROP_BGP_CONFIGURATOR_STOP_BGP_ARGS_0,
  PROP_BGP_CONFIGURATOR_STOP_BGP_ARGS_AS_NUMBER
};

/* reads a bgp_configurator_stop_bgp_args object */
static gint32
bgp_configurator_stop_bgp_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorStopBgpArgs * this_object = BGP_CONFIGURATOR_STOP_BGP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->asNumber, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asNumber = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_stop_bgp_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorStopBgpArgs * this_object = BGP_CONFIGURATOR_STOP_BGP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorStopBgpArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asNumber", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->asNumber, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_stop_bgp_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  BgpConfiguratorStopBgpArgs *self = BGP_CONFIGURATOR_STOP_BGP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_STOP_BGP_ARGS_AS_NUMBER:
      self->asNumber = g_value_get_int64 (value);
      self->__isset_asNumber = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_stop_bgp_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  BgpConfiguratorStopBgpArgs *self = BGP_CONFIGURATOR_STOP_BGP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_STOP_BGP_ARGS_AS_NUMBER:
      g_value_set_int64 (value, self->asNumber);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_stop_bgp_args_instance_init (BgpConfiguratorStopBgpArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->asNumber = 0;
  object->__isset_asNumber = FALSE;
}

static void 
bgp_configurator_stop_bgp_args_finalize (GObject *object)
{
  BgpConfiguratorStopBgpArgs *tobject = BGP_CONFIGURATOR_STOP_BGP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_stop_bgp_args_class_init (BgpConfiguratorStopBgpArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_stop_bgp_args_read;
  struct_class->write = bgp_configurator_stop_bgp_args_write;

  gobject_class->finalize = bgp_configurator_stop_bgp_args_finalize;
  gobject_class->get_property = bgp_configurator_stop_bgp_args_get_property;
  gobject_class->set_property = bgp_configurator_stop_bgp_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_STOP_BGP_ARGS_AS_NUMBER,
     g_param_spec_int64 ("asNumber",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
bgp_configurator_stop_bgp_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorStopBgpArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_stop_bgp_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorStopBgpArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_stop_bgp_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorStopBgpArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorStopBgpResultProperties
{
  PROP_BGP_CONFIGURATOR_STOP_BGP_RESULT_0,
  PROP_BGP_CONFIGURATOR_STOP_BGP_RESULT_SUCCESS
};

/* reads a bgp_configurator_stop_bgp_result object */
static gint32
bgp_configurator_stop_bgp_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorStopBgpResult * this_object = BGP_CONFIGURATOR_STOP_BGP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_stop_bgp_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorStopBgpResult * this_object = BGP_CONFIGURATOR_STOP_BGP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorStopBgpResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_stop_bgp_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorStopBgpResult *self = BGP_CONFIGURATOR_STOP_BGP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_STOP_BGP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_stop_bgp_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorStopBgpResult *self = BGP_CONFIGURATOR_STOP_BGP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_STOP_BGP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_stop_bgp_result_instance_init (BgpConfiguratorStopBgpResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_stop_bgp_result_finalize (GObject *object)
{
  BgpConfiguratorStopBgpResult *tobject = BGP_CONFIGURATOR_STOP_BGP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_stop_bgp_result_class_init (BgpConfiguratorStopBgpResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_stop_bgp_result_read;
  struct_class->write = bgp_configurator_stop_bgp_result_write;

  gobject_class->finalize = bgp_configurator_stop_bgp_result_finalize;
  gobject_class->get_property = bgp_configurator_stop_bgp_result_get_property;
  gobject_class->set_property = bgp_configurator_stop_bgp_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_STOP_BGP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_stop_bgp_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorStopBgpResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_stop_bgp_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorStopBgpResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_stop_bgp_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorStopBgpResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorCreatePeerArgsProperties
{
  PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_0,
  PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_IP_ADDRESS,
  PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_AS_NUMBER
};

/* reads a bgp_configurator_create_peer_args object */
static gint32
bgp_configurator_create_peer_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorCreatePeerArgs * this_object = BGP_CONFIGURATOR_CREATE_PEER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->ipAddress != NULL)
          {
            g_free(this_object->ipAddress);
            this_object->ipAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ipAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ipAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->asNumber, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_asNumber = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_create_peer_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorCreatePeerArgs * this_object = BGP_CONFIGURATOR_CREATE_PEER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorCreatePeerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ipAddress", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ipAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asNumber", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->asNumber, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_create_peer_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorCreatePeerArgs *self = BGP_CONFIGURATOR_CREATE_PEER_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_IP_ADDRESS:
      if (self->ipAddress != NULL)
        g_free (self->ipAddress);
      self->ipAddress = g_value_dup_string (value);
      self->__isset_ipAddress = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_AS_NUMBER:
      self->asNumber = g_value_get_int64 (value);
      self->__isset_asNumber = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_create_peer_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorCreatePeerArgs *self = BGP_CONFIGURATOR_CREATE_PEER_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_IP_ADDRESS:
      g_value_set_string (value, self->ipAddress);
      break;

    case PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_AS_NUMBER:
      g_value_set_int64 (value, self->asNumber);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_create_peer_args_instance_init (BgpConfiguratorCreatePeerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ipAddress = NULL;
  object->__isset_ipAddress = FALSE;
  object->asNumber = 0;
  object->__isset_asNumber = FALSE;
}

static void 
bgp_configurator_create_peer_args_finalize (GObject *object)
{
  BgpConfiguratorCreatePeerArgs *tobject = BGP_CONFIGURATOR_CREATE_PEER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ipAddress != NULL)
  {
    g_free(tobject->ipAddress);
    tobject->ipAddress = NULL;
  }
}

static void
bgp_configurator_create_peer_args_class_init (BgpConfiguratorCreatePeerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_create_peer_args_read;
  struct_class->write = bgp_configurator_create_peer_args_write;

  gobject_class->finalize = bgp_configurator_create_peer_args_finalize;
  gobject_class->get_property = bgp_configurator_create_peer_args_get_property;
  gobject_class->set_property = bgp_configurator_create_peer_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_IP_ADDRESS,
     g_param_spec_string ("ipAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_CREATE_PEER_ARGS_AS_NUMBER,
     g_param_spec_int64 ("asNumber",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
bgp_configurator_create_peer_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorCreatePeerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_create_peer_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorCreatePeerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_create_peer_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorCreatePeerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorCreatePeerResultProperties
{
  PROP_BGP_CONFIGURATOR_CREATE_PEER_RESULT_0,
  PROP_BGP_CONFIGURATOR_CREATE_PEER_RESULT_SUCCESS
};

/* reads a bgp_configurator_create_peer_result object */
static gint32
bgp_configurator_create_peer_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorCreatePeerResult * this_object = BGP_CONFIGURATOR_CREATE_PEER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_create_peer_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorCreatePeerResult * this_object = BGP_CONFIGURATOR_CREATE_PEER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorCreatePeerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_create_peer_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  BgpConfiguratorCreatePeerResult *self = BGP_CONFIGURATOR_CREATE_PEER_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_CREATE_PEER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_create_peer_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  BgpConfiguratorCreatePeerResult *self = BGP_CONFIGURATOR_CREATE_PEER_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_CREATE_PEER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_create_peer_result_instance_init (BgpConfiguratorCreatePeerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_create_peer_result_finalize (GObject *object)
{
  BgpConfiguratorCreatePeerResult *tobject = BGP_CONFIGURATOR_CREATE_PEER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_create_peer_result_class_init (BgpConfiguratorCreatePeerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_create_peer_result_read;
  struct_class->write = bgp_configurator_create_peer_result_write;

  gobject_class->finalize = bgp_configurator_create_peer_result_finalize;
  gobject_class->get_property = bgp_configurator_create_peer_result_get_property;
  gobject_class->set_property = bgp_configurator_create_peer_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_CREATE_PEER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_create_peer_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorCreatePeerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_create_peer_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorCreatePeerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_create_peer_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorCreatePeerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDeletePeerArgsProperties
{
  PROP_BGP_CONFIGURATOR_DELETE_PEER_ARGS_0,
  PROP_BGP_CONFIGURATOR_DELETE_PEER_ARGS_IP_ADDRESS
};

/* reads a bgp_configurator_delete_peer_args object */
static gint32
bgp_configurator_delete_peer_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDeletePeerArgs * this_object = BGP_CONFIGURATOR_DELETE_PEER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->ipAddress != NULL)
          {
            g_free(this_object->ipAddress);
            this_object->ipAddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ipAddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ipAddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_delete_peer_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDeletePeerArgs * this_object = BGP_CONFIGURATOR_DELETE_PEER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDeletePeerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ipAddress", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ipAddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_delete_peer_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorDeletePeerArgs *self = BGP_CONFIGURATOR_DELETE_PEER_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DELETE_PEER_ARGS_IP_ADDRESS:
      if (self->ipAddress != NULL)
        g_free (self->ipAddress);
      self->ipAddress = g_value_dup_string (value);
      self->__isset_ipAddress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_delete_peer_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  BgpConfiguratorDeletePeerArgs *self = BGP_CONFIGURATOR_DELETE_PEER_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DELETE_PEER_ARGS_IP_ADDRESS:
      g_value_set_string (value, self->ipAddress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_delete_peer_args_instance_init (BgpConfiguratorDeletePeerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ipAddress = NULL;
  object->__isset_ipAddress = FALSE;
}

static void 
bgp_configurator_delete_peer_args_finalize (GObject *object)
{
  BgpConfiguratorDeletePeerArgs *tobject = BGP_CONFIGURATOR_DELETE_PEER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ipAddress != NULL)
  {
    g_free(tobject->ipAddress);
    tobject->ipAddress = NULL;
  }
}

static void
bgp_configurator_delete_peer_args_class_init (BgpConfiguratorDeletePeerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_delete_peer_args_read;
  struct_class->write = bgp_configurator_delete_peer_args_write;

  gobject_class->finalize = bgp_configurator_delete_peer_args_finalize;
  gobject_class->get_property = bgp_configurator_delete_peer_args_get_property;
  gobject_class->set_property = bgp_configurator_delete_peer_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DELETE_PEER_ARGS_IP_ADDRESS,
     g_param_spec_string ("ipAddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_delete_peer_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDeletePeerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_delete_peer_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDeletePeerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_delete_peer_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDeletePeerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDeletePeerResultProperties
{
  PROP_BGP_CONFIGURATOR_DELETE_PEER_RESULT_0,
  PROP_BGP_CONFIGURATOR_DELETE_PEER_RESULT_SUCCESS
};

/* reads a bgp_configurator_delete_peer_result object */
static gint32
bgp_configurator_delete_peer_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDeletePeerResult * this_object = BGP_CONFIGURATOR_DELETE_PEER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_delete_peer_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDeletePeerResult * this_object = BGP_CONFIGURATOR_DELETE_PEER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDeletePeerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_delete_peer_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  BgpConfiguratorDeletePeerResult *self = BGP_CONFIGURATOR_DELETE_PEER_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DELETE_PEER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_delete_peer_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  BgpConfiguratorDeletePeerResult *self = BGP_CONFIGURATOR_DELETE_PEER_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DELETE_PEER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_delete_peer_result_instance_init (BgpConfiguratorDeletePeerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_delete_peer_result_finalize (GObject *object)
{
  BgpConfiguratorDeletePeerResult *tobject = BGP_CONFIGURATOR_DELETE_PEER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_delete_peer_result_class_init (BgpConfiguratorDeletePeerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_delete_peer_result_read;
  struct_class->write = bgp_configurator_delete_peer_result_write;

  gobject_class->finalize = bgp_configurator_delete_peer_result_finalize;
  gobject_class->get_property = bgp_configurator_delete_peer_result_get_property;
  gobject_class->set_property = bgp_configurator_delete_peer_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DELETE_PEER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_delete_peer_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDeletePeerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_delete_peer_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDeletePeerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_delete_peer_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDeletePeerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorAddVrfArgsProperties
{
  PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_0,
  PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_L_TYPE,
  PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_RD,
  PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_IRTS,
  PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_ERTS
};

/* reads a bgp_configurator_add_vrf_args object */
static gint32
bgp_configurator_add_vrf_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorAddVrfArgs * this_object = BGP_CONFIGURATOR_ADD_VRF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->l_type = (layer_type)ecast2;
          this_object->__isset_l_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem3 = NULL;
              if (_elem3 != NULL)
              {
                g_free(_elem3);
                _elem3 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem3, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->irts, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_irts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem4 = NULL;
              if (_elem4 != NULL)
              {
                g_free(_elem4);
                _elem4 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->erts, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_erts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_add_vrf_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorAddVrfArgs * this_object = BGP_CONFIGURATOR_ADD_VRF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorAddVrfArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->l_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "irts", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->irts ? this_object->irts->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->irts ? this_object->irts->len : 0); i5++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->irts, i5)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "erts", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->erts ? this_object->erts->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->erts ? this_object->erts->len : 0); i6++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->erts, i6)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_add_vrf_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  BgpConfiguratorAddVrfArgs *self = BGP_CONFIGURATOR_ADD_VRF_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_L_TYPE:
      self->l_type = g_value_get_int (value);
      self->__isset_l_type = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_IRTS:
      if (self->irts != NULL)
        g_ptr_array_unref (self->irts);
      self->irts = g_value_dup_boxed (value);
      self->__isset_irts = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_ERTS:
      if (self->erts != NULL)
        g_ptr_array_unref (self->erts);
      self->erts = g_value_dup_boxed (value);
      self->__isset_erts = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_add_vrf_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  BgpConfiguratorAddVrfArgs *self = BGP_CONFIGURATOR_ADD_VRF_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_L_TYPE:
      g_value_set_int (value, self->l_type);
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_IRTS:
      g_value_set_boxed (value, self->irts);
      break;

    case PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_ERTS:
      g_value_set_boxed (value, self->erts);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_add_vrf_args_instance_init (BgpConfiguratorAddVrfArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_l_type = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->irts = g_ptr_array_new_with_free_func (g_free);
  object->__isset_irts = FALSE;
  object->erts = g_ptr_array_new_with_free_func (g_free);
  object->__isset_erts = FALSE;
}

static void 
bgp_configurator_add_vrf_args_finalize (GObject *object)
{
  BgpConfiguratorAddVrfArgs *tobject = BGP_CONFIGURATOR_ADD_VRF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->irts != NULL)
  {
    g_ptr_array_unref (tobject->irts);
    tobject->irts = NULL;
  }
  if (tobject->erts != NULL)
  {
    g_ptr_array_unref (tobject->erts);
    tobject->erts = NULL;
  }
}

static void
bgp_configurator_add_vrf_args_class_init (BgpConfiguratorAddVrfArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_add_vrf_args_read;
  struct_class->write = bgp_configurator_add_vrf_args_write;

  gobject_class->finalize = bgp_configurator_add_vrf_args_finalize;
  gobject_class->get_property = bgp_configurator_add_vrf_args_get_property;
  gobject_class->set_property = bgp_configurator_add_vrf_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_L_TYPE,
     g_param_spec_int ("l_type",
                       NULL,
                       NULL,
                       1,
                       2,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_IRTS,
     g_param_spec_boxed ("irts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ADD_VRF_ARGS_ERTS,
     g_param_spec_boxed ("erts",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
bgp_configurator_add_vrf_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorAddVrfArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_add_vrf_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorAddVrfArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_add_vrf_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorAddVrfArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorAddVrfResultProperties
{
  PROP_BGP_CONFIGURATOR_ADD_VRF_RESULT_0,
  PROP_BGP_CONFIGURATOR_ADD_VRF_RESULT_SUCCESS
};

/* reads a bgp_configurator_add_vrf_result object */
static gint32
bgp_configurator_add_vrf_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorAddVrfResult * this_object = BGP_CONFIGURATOR_ADD_VRF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_add_vrf_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorAddVrfResult * this_object = BGP_CONFIGURATOR_ADD_VRF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorAddVrfResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_add_vrf_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorAddVrfResult *self = BGP_CONFIGURATOR_ADD_VRF_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ADD_VRF_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_add_vrf_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorAddVrfResult *self = BGP_CONFIGURATOR_ADD_VRF_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ADD_VRF_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_add_vrf_result_instance_init (BgpConfiguratorAddVrfResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_add_vrf_result_finalize (GObject *object)
{
  BgpConfiguratorAddVrfResult *tobject = BGP_CONFIGURATOR_ADD_VRF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_add_vrf_result_class_init (BgpConfiguratorAddVrfResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_add_vrf_result_read;
  struct_class->write = bgp_configurator_add_vrf_result_write;

  gobject_class->finalize = bgp_configurator_add_vrf_result_finalize;
  gobject_class->get_property = bgp_configurator_add_vrf_result_get_property;
  gobject_class->set_property = bgp_configurator_add_vrf_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ADD_VRF_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_add_vrf_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorAddVrfResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_add_vrf_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorAddVrfResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_add_vrf_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorAddVrfResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDelVrfArgsProperties
{
  PROP_BGP_CONFIGURATOR_DEL_VRF_ARGS_0,
  PROP_BGP_CONFIGURATOR_DEL_VRF_ARGS_RD
};

/* reads a bgp_configurator_del_vrf_args object */
static gint32
bgp_configurator_del_vrf_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDelVrfArgs * this_object = BGP_CONFIGURATOR_DEL_VRF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_del_vrf_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDelVrfArgs * this_object = BGP_CONFIGURATOR_DEL_VRF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDelVrfArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_del_vrf_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  BgpConfiguratorDelVrfArgs *self = BGP_CONFIGURATOR_DEL_VRF_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DEL_VRF_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_del_vrf_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  BgpConfiguratorDelVrfArgs *self = BGP_CONFIGURATOR_DEL_VRF_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DEL_VRF_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_del_vrf_args_instance_init (BgpConfiguratorDelVrfArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rd = NULL;
  object->__isset_rd = FALSE;
}

static void 
bgp_configurator_del_vrf_args_finalize (GObject *object)
{
  BgpConfiguratorDelVrfArgs *tobject = BGP_CONFIGURATOR_DEL_VRF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
}

static void
bgp_configurator_del_vrf_args_class_init (BgpConfiguratorDelVrfArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_del_vrf_args_read;
  struct_class->write = bgp_configurator_del_vrf_args_write;

  gobject_class->finalize = bgp_configurator_del_vrf_args_finalize;
  gobject_class->get_property = bgp_configurator_del_vrf_args_get_property;
  gobject_class->set_property = bgp_configurator_del_vrf_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DEL_VRF_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_del_vrf_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDelVrfArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_del_vrf_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDelVrfArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_del_vrf_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDelVrfArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDelVrfResultProperties
{
  PROP_BGP_CONFIGURATOR_DEL_VRF_RESULT_0,
  PROP_BGP_CONFIGURATOR_DEL_VRF_RESULT_SUCCESS
};

/* reads a bgp_configurator_del_vrf_result object */
static gint32
bgp_configurator_del_vrf_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDelVrfResult * this_object = BGP_CONFIGURATOR_DEL_VRF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_del_vrf_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDelVrfResult * this_object = BGP_CONFIGURATOR_DEL_VRF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDelVrfResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_del_vrf_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorDelVrfResult *self = BGP_CONFIGURATOR_DEL_VRF_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DEL_VRF_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_del_vrf_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  BgpConfiguratorDelVrfResult *self = BGP_CONFIGURATOR_DEL_VRF_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DEL_VRF_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_del_vrf_result_instance_init (BgpConfiguratorDelVrfResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_del_vrf_result_finalize (GObject *object)
{
  BgpConfiguratorDelVrfResult *tobject = BGP_CONFIGURATOR_DEL_VRF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_del_vrf_result_class_init (BgpConfiguratorDelVrfResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_del_vrf_result_read;
  struct_class->write = bgp_configurator_del_vrf_result_write;

  gobject_class->finalize = bgp_configurator_del_vrf_result_finalize;
  gobject_class->get_property = bgp_configurator_del_vrf_result_get_property;
  gobject_class->set_property = bgp_configurator_del_vrf_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DEL_VRF_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_del_vrf_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDelVrfResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_del_vrf_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDelVrfResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_del_vrf_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDelVrfResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorPushRouteArgsProperties
{
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_0,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_P_TYPE,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_PREFIX,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_NEXTHOP,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_RD,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ETHTAG,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ESI,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_MACADDRESS,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L3LABEL,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L2LABEL,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ENC_TYPE,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ROUTERMAC
};

/* reads a bgp_configurator_push_route_args object */
static gint32
bgp_configurator_push_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorPushRouteArgs * this_object = BGP_CONFIGURATOR_PUSH_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->p_type = (protocol_type)ecast7;
          this_object->__isset_p_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->nexthop != NULL)
          {
            g_free(this_object->nexthop);
            this_object->nexthop = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nexthop, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nexthop = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ethtag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ethtag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->esi != NULL)
          {
            g_free(this_object->esi);
            this_object->esi = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->esi, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_esi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->macaddress != NULL)
          {
            g_free(this_object->macaddress);
            this_object->macaddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->macaddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_macaddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l3label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l3label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l2label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l2label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->enc_type = (encap_type)ecast8;
          this_object->__isset_enc_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->routermac != NULL)
          {
            g_free(this_object->routermac);
            this_object->routermac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->routermac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_routermac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_push_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorPushRouteArgs * this_object = BGP_CONFIGURATOR_PUSH_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorPushRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "p_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->p_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nexthop", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->nexthop, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ethtag", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ethtag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "esi", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->esi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "macaddress", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->macaddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l3label", T_I32, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l3label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l2label", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l2label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enc_type", T_I32, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->enc_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "routermac", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->routermac, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_push_route_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorPushRouteArgs *self = BGP_CONFIGURATOR_PUSH_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_P_TYPE:
      self->p_type = g_value_get_int (value);
      self->__isset_p_type = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_NEXTHOP:
      if (self->nexthop != NULL)
        g_free (self->nexthop);
      self->nexthop = g_value_dup_string (value);
      self->__isset_nexthop = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ETHTAG:
      self->ethtag = g_value_get_int64 (value);
      self->__isset_ethtag = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ESI:
      if (self->esi != NULL)
        g_free (self->esi);
      self->esi = g_value_dup_string (value);
      self->__isset_esi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_MACADDRESS:
      if (self->macaddress != NULL)
        g_free (self->macaddress);
      self->macaddress = g_value_dup_string (value);
      self->__isset_macaddress = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L3LABEL:
      self->l3label = g_value_get_int (value);
      self->__isset_l3label = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L2LABEL:
      self->l2label = g_value_get_int (value);
      self->__isset_l2label = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ENC_TYPE:
      self->enc_type = g_value_get_int (value);
      self->__isset_enc_type = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ROUTERMAC:
      if (self->routermac != NULL)
        g_free (self->routermac);
      self->routermac = g_value_dup_string (value);
      self->__isset_routermac = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_push_route_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorPushRouteArgs *self = BGP_CONFIGURATOR_PUSH_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_P_TYPE:
      g_value_set_int (value, self->p_type);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_NEXTHOP:
      g_value_set_string (value, self->nexthop);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ETHTAG:
      g_value_set_int64 (value, self->ethtag);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ESI:
      g_value_set_string (value, self->esi);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_MACADDRESS:
      g_value_set_string (value, self->macaddress);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L3LABEL:
      g_value_set_int (value, self->l3label);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L2LABEL:
      g_value_set_int (value, self->l2label);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ENC_TYPE:
      g_value_set_int (value, self->enc_type);
      break;

    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ROUTERMAC:
      g_value_set_string (value, self->routermac);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_push_route_args_instance_init (BgpConfiguratorPushRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_p_type = FALSE;
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->nexthop = NULL;
  object->__isset_nexthop = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->ethtag = 0;
  object->__isset_ethtag = FALSE;
  object->esi = NULL;
  object->__isset_esi = FALSE;
  object->macaddress = NULL;
  object->__isset_macaddress = FALSE;
  object->l3label = 0;
  object->__isset_l3label = FALSE;
  object->l2label = 0;
  object->__isset_l2label = FALSE;
  object->__isset_enc_type = FALSE;
  object->routermac = NULL;
  object->__isset_routermac = FALSE;
}

static void 
bgp_configurator_push_route_args_finalize (GObject *object)
{
  BgpConfiguratorPushRouteArgs *tobject = BGP_CONFIGURATOR_PUSH_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
  if (tobject->nexthop != NULL)
  {
    g_free(tobject->nexthop);
    tobject->nexthop = NULL;
  }
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->esi != NULL)
  {
    g_free(tobject->esi);
    tobject->esi = NULL;
  }
  if (tobject->macaddress != NULL)
  {
    g_free(tobject->macaddress);
    tobject->macaddress = NULL;
  }
  if (tobject->routermac != NULL)
  {
    g_free(tobject->routermac);
    tobject->routermac = NULL;
  }
}

static void
bgp_configurator_push_route_args_class_init (BgpConfiguratorPushRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_push_route_args_read;
  struct_class->write = bgp_configurator_push_route_args_write;

  gobject_class->finalize = bgp_configurator_push_route_args_finalize;
  gobject_class->get_property = bgp_configurator_push_route_args_get_property;
  gobject_class->set_property = bgp_configurator_push_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_P_TYPE,
     g_param_spec_int ("p_type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_NEXTHOP,
     g_param_spec_string ("nexthop",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ETHTAG,
     g_param_spec_int64 ("ethtag",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ESI,
     g_param_spec_string ("esi",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_MACADDRESS,
     g_param_spec_string ("macaddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L3LABEL,
     g_param_spec_int ("l3label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_L2LABEL,
     g_param_spec_int ("l2label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ENC_TYPE,
     g_param_spec_int ("enc_type",
                       NULL,
                       NULL,
                       1,
                       10,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_ARGS_ROUTERMAC,
     g_param_spec_string ("routermac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_push_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorPushRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_push_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorPushRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_push_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorPushRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorPushRouteResultProperties
{
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_RESULT_0,
  PROP_BGP_CONFIGURATOR_PUSH_ROUTE_RESULT_SUCCESS
};

/* reads a bgp_configurator_push_route_result object */
static gint32
bgp_configurator_push_route_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorPushRouteResult * this_object = BGP_CONFIGURATOR_PUSH_ROUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_push_route_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorPushRouteResult * this_object = BGP_CONFIGURATOR_PUSH_ROUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorPushRouteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_push_route_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorPushRouteResult *self = BGP_CONFIGURATOR_PUSH_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_push_route_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorPushRouteResult *self = BGP_CONFIGURATOR_PUSH_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_PUSH_ROUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_push_route_result_instance_init (BgpConfiguratorPushRouteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_push_route_result_finalize (GObject *object)
{
  BgpConfiguratorPushRouteResult *tobject = BGP_CONFIGURATOR_PUSH_ROUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_push_route_result_class_init (BgpConfiguratorPushRouteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_push_route_result_read;
  struct_class->write = bgp_configurator_push_route_result_write;

  gobject_class->finalize = bgp_configurator_push_route_result_finalize;
  gobject_class->get_property = bgp_configurator_push_route_result_get_property;
  gobject_class->set_property = bgp_configurator_push_route_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_PUSH_ROUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_push_route_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorPushRouteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_push_route_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorPushRouteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_push_route_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorPushRouteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorWithdrawRouteArgsProperties
{
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_0,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_P_TYPE,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_PREFIX,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_RD,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ETHTAG,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ESI,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_MACADDRESS
};

/* reads a bgp_configurator_withdraw_route_args object */
static gint32
bgp_configurator_withdraw_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorWithdrawRouteArgs * this_object = BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast9;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->p_type = (protocol_type)ecast9;
          this_object->__isset_p_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ethtag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ethtag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->esi != NULL)
          {
            g_free(this_object->esi);
            this_object->esi = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->esi, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_esi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->macaddress != NULL)
          {
            g_free(this_object->macaddress);
            this_object->macaddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->macaddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_macaddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_withdraw_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorWithdrawRouteArgs * this_object = BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorWithdrawRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "p_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->p_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ethtag", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ethtag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "esi", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->esi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "macaddress", T_STRING, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->macaddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_withdraw_route_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  BgpConfiguratorWithdrawRouteArgs *self = BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_P_TYPE:
      self->p_type = g_value_get_int (value);
      self->__isset_p_type = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ETHTAG:
      self->ethtag = g_value_get_int64 (value);
      self->__isset_ethtag = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ESI:
      if (self->esi != NULL)
        g_free (self->esi);
      self->esi = g_value_dup_string (value);
      self->__isset_esi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_MACADDRESS:
      if (self->macaddress != NULL)
        g_free (self->macaddress);
      self->macaddress = g_value_dup_string (value);
      self->__isset_macaddress = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_withdraw_route_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  BgpConfiguratorWithdrawRouteArgs *self = BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_P_TYPE:
      g_value_set_int (value, self->p_type);
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ETHTAG:
      g_value_set_int64 (value, self->ethtag);
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ESI:
      g_value_set_string (value, self->esi);
      break;

    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_MACADDRESS:
      g_value_set_string (value, self->macaddress);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_withdraw_route_args_instance_init (BgpConfiguratorWithdrawRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_p_type = FALSE;
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->ethtag = 0;
  object->__isset_ethtag = FALSE;
  object->esi = NULL;
  object->__isset_esi = FALSE;
  object->macaddress = NULL;
  object->__isset_macaddress = FALSE;
}

static void 
bgp_configurator_withdraw_route_args_finalize (GObject *object)
{
  BgpConfiguratorWithdrawRouteArgs *tobject = BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->esi != NULL)
  {
    g_free(tobject->esi);
    tobject->esi = NULL;
  }
  if (tobject->macaddress != NULL)
  {
    g_free(tobject->macaddress);
    tobject->macaddress = NULL;
  }
}

static void
bgp_configurator_withdraw_route_args_class_init (BgpConfiguratorWithdrawRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_withdraw_route_args_read;
  struct_class->write = bgp_configurator_withdraw_route_args_write;

  gobject_class->finalize = bgp_configurator_withdraw_route_args_finalize;
  gobject_class->get_property = bgp_configurator_withdraw_route_args_get_property;
  gobject_class->set_property = bgp_configurator_withdraw_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_P_TYPE,
     g_param_spec_int ("p_type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ETHTAG,
     g_param_spec_int64 ("ethtag",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_ESI,
     g_param_spec_string ("esi",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_ARGS_MACADDRESS,
     g_param_spec_string ("macaddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_withdraw_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorWithdrawRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_withdraw_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorWithdrawRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_withdraw_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorWithdrawRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorWithdrawRouteResultProperties
{
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT_0,
  PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT_SUCCESS
};

/* reads a bgp_configurator_withdraw_route_result object */
static gint32
bgp_configurator_withdraw_route_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorWithdrawRouteResult * this_object = BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_withdraw_route_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorWithdrawRouteResult * this_object = BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorWithdrawRouteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_withdraw_route_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorWithdrawRouteResult *self = BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_withdraw_route_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorWithdrawRouteResult *self = BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_withdraw_route_result_instance_init (BgpConfiguratorWithdrawRouteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_withdraw_route_result_finalize (GObject *object)
{
  BgpConfiguratorWithdrawRouteResult *tobject = BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_withdraw_route_result_class_init (BgpConfiguratorWithdrawRouteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_withdraw_route_result_read;
  struct_class->write = bgp_configurator_withdraw_route_result_write;

  gobject_class->finalize = bgp_configurator_withdraw_route_result_finalize;
  gobject_class->get_property = bgp_configurator_withdraw_route_result_get_property;
  gobject_class->set_property = bgp_configurator_withdraw_route_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_WITHDRAW_ROUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_withdraw_route_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorWithdrawRouteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_withdraw_route_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorWithdrawRouteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_withdraw_route_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorWithdrawRouteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetEbgpMultihopArgsProperties
{
  PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_0,
  PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_PEER_IP,
  PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_N_HOPS
};

/* reads a bgp_configurator_set_ebgp_multihop_args object */
static gint32
bgp_configurator_set_ebgp_multihop_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetEbgpMultihopArgs * this_object = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->nHops, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nHops = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_ebgp_multihop_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetEbgpMultihopArgs * this_object = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetEbgpMultihopArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nHops", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->nHops, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_ebgp_multihop_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorSetEbgpMultihopArgs *self = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_N_HOPS:
      self->nHops = g_value_get_int (value);
      self->__isset_nHops = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_ebgp_multihop_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorSetEbgpMultihopArgs *self = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_N_HOPS:
      g_value_set_int (value, self->nHops);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_ebgp_multihop_args_instance_init (BgpConfiguratorSetEbgpMultihopArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
  object->nHops = 0;
  object->__isset_nHops = FALSE;
}

static void 
bgp_configurator_set_ebgp_multihop_args_finalize (GObject *object)
{
  BgpConfiguratorSetEbgpMultihopArgs *tobject = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
}

static void
bgp_configurator_set_ebgp_multihop_args_class_init (BgpConfiguratorSetEbgpMultihopArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_ebgp_multihop_args_read;
  struct_class->write = bgp_configurator_set_ebgp_multihop_args_write;

  gobject_class->finalize = bgp_configurator_set_ebgp_multihop_args_finalize;
  gobject_class->get_property = bgp_configurator_set_ebgp_multihop_args_get_property;
  gobject_class->set_property = bgp_configurator_set_ebgp_multihop_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_ARGS_N_HOPS,
     g_param_spec_int ("nHops",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_set_ebgp_multihop_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetEbgpMultihopArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_ebgp_multihop_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetEbgpMultihopArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_ebgp_multihop_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetEbgpMultihopArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetEbgpMultihopResultProperties
{
  PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT_0,
  PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT_SUCCESS
};

/* reads a bgp_configurator_set_ebgp_multihop_result object */
static gint32
bgp_configurator_set_ebgp_multihop_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetEbgpMultihopResult * this_object = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_ebgp_multihop_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetEbgpMultihopResult * this_object = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetEbgpMultihopResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_ebgp_multihop_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorSetEbgpMultihopResult *self = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_ebgp_multihop_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorSetEbgpMultihopResult *self = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_ebgp_multihop_result_instance_init (BgpConfiguratorSetEbgpMultihopResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_set_ebgp_multihop_result_finalize (GObject *object)
{
  BgpConfiguratorSetEbgpMultihopResult *tobject = BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_set_ebgp_multihop_result_class_init (BgpConfiguratorSetEbgpMultihopResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_ebgp_multihop_result_read;
  struct_class->write = bgp_configurator_set_ebgp_multihop_result_write;

  gobject_class->finalize = bgp_configurator_set_ebgp_multihop_result_finalize;
  gobject_class->get_property = bgp_configurator_set_ebgp_multihop_result_get_property;
  gobject_class->set_property = bgp_configurator_set_ebgp_multihop_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_EBGP_MULTIHOP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_set_ebgp_multihop_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetEbgpMultihopResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_ebgp_multihop_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetEbgpMultihopResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_ebgp_multihop_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetEbgpMultihopResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorUnsetEbgpMultihopArgsProperties
{
  PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS_0,
  PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS_PEER_IP
};

/* reads a bgp_configurator_unset_ebgp_multihop_args object */
static gint32
bgp_configurator_unset_ebgp_multihop_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorUnsetEbgpMultihopArgs * this_object = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_unset_ebgp_multihop_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorUnsetEbgpMultihopArgs * this_object = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorUnsetEbgpMultihopArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_unset_ebgp_multihop_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorUnsetEbgpMultihopArgs *self = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_unset_ebgp_multihop_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorUnsetEbgpMultihopArgs *self = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_unset_ebgp_multihop_args_instance_init (BgpConfiguratorUnsetEbgpMultihopArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
}

static void 
bgp_configurator_unset_ebgp_multihop_args_finalize (GObject *object)
{
  BgpConfiguratorUnsetEbgpMultihopArgs *tobject = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
}

static void
bgp_configurator_unset_ebgp_multihop_args_class_init (BgpConfiguratorUnsetEbgpMultihopArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_unset_ebgp_multihop_args_read;
  struct_class->write = bgp_configurator_unset_ebgp_multihop_args_write;

  gobject_class->finalize = bgp_configurator_unset_ebgp_multihop_args_finalize;
  gobject_class->get_property = bgp_configurator_unset_ebgp_multihop_args_get_property;
  gobject_class->set_property = bgp_configurator_unset_ebgp_multihop_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_unset_ebgp_multihop_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorUnsetEbgpMultihopArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_unset_ebgp_multihop_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorUnsetEbgpMultihopArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_unset_ebgp_multihop_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorUnsetEbgpMultihopArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorUnsetEbgpMultihopResultProperties
{
  PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT_0,
  PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT_SUCCESS
};

/* reads a bgp_configurator_unset_ebgp_multihop_result object */
static gint32
bgp_configurator_unset_ebgp_multihop_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorUnsetEbgpMultihopResult * this_object = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_unset_ebgp_multihop_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorUnsetEbgpMultihopResult * this_object = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorUnsetEbgpMultihopResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_unset_ebgp_multihop_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorUnsetEbgpMultihopResult *self = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_unset_ebgp_multihop_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorUnsetEbgpMultihopResult *self = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_unset_ebgp_multihop_result_instance_init (BgpConfiguratorUnsetEbgpMultihopResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_unset_ebgp_multihop_result_finalize (GObject *object)
{
  BgpConfiguratorUnsetEbgpMultihopResult *tobject = BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_unset_ebgp_multihop_result_class_init (BgpConfiguratorUnsetEbgpMultihopResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_unset_ebgp_multihop_result_read;
  struct_class->write = bgp_configurator_unset_ebgp_multihop_result_write;

  gobject_class->finalize = bgp_configurator_unset_ebgp_multihop_result_finalize;
  gobject_class->get_property = bgp_configurator_unset_ebgp_multihop_result_get_property;
  gobject_class->set_property = bgp_configurator_unset_ebgp_multihop_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_UNSET_EBGP_MULTIHOP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_unset_ebgp_multihop_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorUnsetEbgpMultihopResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_unset_ebgp_multihop_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorUnsetEbgpMultihopResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_unset_ebgp_multihop_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorUnsetEbgpMultihopResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetUpdateSourceArgsProperties
{
  PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_0,
  PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_PEER_IP,
  PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_SRC_IP
};

/* reads a bgp_configurator_set_update_source_args object */
static gint32
bgp_configurator_set_update_source_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetUpdateSourceArgs * this_object = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->srcIp != NULL)
          {
            g_free(this_object->srcIp);
            this_object->srcIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->srcIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_srcIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_update_source_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetUpdateSourceArgs * this_object = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetUpdateSourceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "srcIp", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->srcIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_update_source_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorSetUpdateSourceArgs *self = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_SRC_IP:
      if (self->srcIp != NULL)
        g_free (self->srcIp);
      self->srcIp = g_value_dup_string (value);
      self->__isset_srcIp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_update_source_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorSetUpdateSourceArgs *self = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_SRC_IP:
      g_value_set_string (value, self->srcIp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_update_source_args_instance_init (BgpConfiguratorSetUpdateSourceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
  object->srcIp = NULL;
  object->__isset_srcIp = FALSE;
}

static void 
bgp_configurator_set_update_source_args_finalize (GObject *object)
{
  BgpConfiguratorSetUpdateSourceArgs *tobject = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
  if (tobject->srcIp != NULL)
  {
    g_free(tobject->srcIp);
    tobject->srcIp = NULL;
  }
}

static void
bgp_configurator_set_update_source_args_class_init (BgpConfiguratorSetUpdateSourceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_update_source_args_read;
  struct_class->write = bgp_configurator_set_update_source_args_write;

  gobject_class->finalize = bgp_configurator_set_update_source_args_finalize;
  gobject_class->get_property = bgp_configurator_set_update_source_args_get_property;
  gobject_class->set_property = bgp_configurator_set_update_source_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_ARGS_SRC_IP,
     g_param_spec_string ("srcIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_set_update_source_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetUpdateSourceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_update_source_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetUpdateSourceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_update_source_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetUpdateSourceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetUpdateSourceResultProperties
{
  PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT_0,
  PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT_SUCCESS
};

/* reads a bgp_configurator_set_update_source_result object */
static gint32
bgp_configurator_set_update_source_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetUpdateSourceResult * this_object = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_update_source_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetUpdateSourceResult * this_object = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetUpdateSourceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_update_source_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorSetUpdateSourceResult *self = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_update_source_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorSetUpdateSourceResult *self = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_update_source_result_instance_init (BgpConfiguratorSetUpdateSourceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_set_update_source_result_finalize (GObject *object)
{
  BgpConfiguratorSetUpdateSourceResult *tobject = BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_set_update_source_result_class_init (BgpConfiguratorSetUpdateSourceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_update_source_result_read;
  struct_class->write = bgp_configurator_set_update_source_result_write;

  gobject_class->finalize = bgp_configurator_set_update_source_result_finalize;
  gobject_class->get_property = bgp_configurator_set_update_source_result_get_property;
  gobject_class->set_property = bgp_configurator_set_update_source_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_UPDATE_SOURCE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_set_update_source_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetUpdateSourceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_update_source_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetUpdateSourceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_update_source_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetUpdateSourceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorUnsetUpdateSourceArgsProperties
{
  PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS_0,
  PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS_PEER_IP
};

/* reads a bgp_configurator_unset_update_source_args object */
static gint32
bgp_configurator_unset_update_source_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorUnsetUpdateSourceArgs * this_object = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_unset_update_source_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorUnsetUpdateSourceArgs * this_object = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorUnsetUpdateSourceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_unset_update_source_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorUnsetUpdateSourceArgs *self = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_unset_update_source_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorUnsetUpdateSourceArgs *self = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_unset_update_source_args_instance_init (BgpConfiguratorUnsetUpdateSourceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
}

static void 
bgp_configurator_unset_update_source_args_finalize (GObject *object)
{
  BgpConfiguratorUnsetUpdateSourceArgs *tobject = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
}

static void
bgp_configurator_unset_update_source_args_class_init (BgpConfiguratorUnsetUpdateSourceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_unset_update_source_args_read;
  struct_class->write = bgp_configurator_unset_update_source_args_write;

  gobject_class->finalize = bgp_configurator_unset_update_source_args_finalize;
  gobject_class->get_property = bgp_configurator_unset_update_source_args_get_property;
  gobject_class->set_property = bgp_configurator_unset_update_source_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_unset_update_source_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorUnsetUpdateSourceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_unset_update_source_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorUnsetUpdateSourceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_unset_update_source_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorUnsetUpdateSourceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorUnsetUpdateSourceResultProperties
{
  PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT_0,
  PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT_SUCCESS
};

/* reads a bgp_configurator_unset_update_source_result object */
static gint32
bgp_configurator_unset_update_source_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorUnsetUpdateSourceResult * this_object = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_unset_update_source_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorUnsetUpdateSourceResult * this_object = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorUnsetUpdateSourceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_unset_update_source_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorUnsetUpdateSourceResult *self = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_unset_update_source_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorUnsetUpdateSourceResult *self = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_unset_update_source_result_instance_init (BgpConfiguratorUnsetUpdateSourceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_unset_update_source_result_finalize (GObject *object)
{
  BgpConfiguratorUnsetUpdateSourceResult *tobject = BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_unset_update_source_result_class_init (BgpConfiguratorUnsetUpdateSourceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_unset_update_source_result_read;
  struct_class->write = bgp_configurator_unset_update_source_result_write;

  gobject_class->finalize = bgp_configurator_unset_update_source_result_finalize;
  gobject_class->get_property = bgp_configurator_unset_update_source_result_get_property;
  gobject_class->set_property = bgp_configurator_unset_update_source_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_UNSET_UPDATE_SOURCE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_unset_update_source_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorUnsetUpdateSourceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_unset_update_source_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorUnsetUpdateSourceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_unset_update_source_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorUnsetUpdateSourceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableAddressFamilyArgsProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_0,
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_PEER_IP,
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_AFI,
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_SAFI
};

/* reads a bgp_configurator_enable_address_family_args object */
static gint32
bgp_configurator_enable_address_family_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableAddressFamilyArgs * this_object = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast10;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->afi = (af_afi)ecast10;
          this_object->__isset_afi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast11;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->safi = (af_safi)ecast11;
          this_object->__isset_safi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_address_family_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableAddressFamilyArgs * this_object = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableAddressFamilyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afi", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->afi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "safi", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->safi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_address_family_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorEnableAddressFamilyArgs *self = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_AFI:
      self->afi = g_value_get_int (value);
      self->__isset_afi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_SAFI:
      self->safi = g_value_get_int (value);
      self->__isset_safi = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_address_family_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  BgpConfiguratorEnableAddressFamilyArgs *self = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_AFI:
      g_value_set_int (value, self->afi);
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_SAFI:
      g_value_set_int (value, self->safi);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_address_family_args_instance_init (BgpConfiguratorEnableAddressFamilyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
  object->__isset_afi = FALSE;
  object->__isset_safi = FALSE;
}

static void 
bgp_configurator_enable_address_family_args_finalize (GObject *object)
{
  BgpConfiguratorEnableAddressFamilyArgs *tobject = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
}

static void
bgp_configurator_enable_address_family_args_class_init (BgpConfiguratorEnableAddressFamilyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_address_family_args_read;
  struct_class->write = bgp_configurator_enable_address_family_args_write;

  gobject_class->finalize = bgp_configurator_enable_address_family_args_finalize;
  gobject_class->get_property = bgp_configurator_enable_address_family_args_get_property;
  gobject_class->set_property = bgp_configurator_enable_address_family_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_AFI,
     g_param_spec_int ("afi",
                       NULL,
                       NULL,
                       1,
                       3,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_ARGS_SAFI,
     g_param_spec_int ("safi",
                       NULL,
                       NULL,
                       4,
                       6,
                       4,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_address_family_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableAddressFamilyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_address_family_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableAddressFamilyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_address_family_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableAddressFamilyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableAddressFamilyResultProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT_0,
  PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT_SUCCESS
};

/* reads a bgp_configurator_enable_address_family_result object */
static gint32
bgp_configurator_enable_address_family_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableAddressFamilyResult * this_object = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_address_family_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableAddressFamilyResult * this_object = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableAddressFamilyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_address_family_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  BgpConfiguratorEnableAddressFamilyResult *self = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_address_family_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  BgpConfiguratorEnableAddressFamilyResult *self = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_address_family_result_instance_init (BgpConfiguratorEnableAddressFamilyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_enable_address_family_result_finalize (GObject *object)
{
  BgpConfiguratorEnableAddressFamilyResult *tobject = BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_enable_address_family_result_class_init (BgpConfiguratorEnableAddressFamilyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_address_family_result_read;
  struct_class->write = bgp_configurator_enable_address_family_result_write;

  gobject_class->finalize = bgp_configurator_enable_address_family_result_finalize;
  gobject_class->get_property = bgp_configurator_enable_address_family_result_get_property;
  gobject_class->set_property = bgp_configurator_enable_address_family_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_ADDRESS_FAMILY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_address_family_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableAddressFamilyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_address_family_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableAddressFamilyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_address_family_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableAddressFamilyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDisableAddressFamilyArgsProperties
{
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_0,
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_PEER_IP,
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_AFI,
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_SAFI
};

/* reads a bgp_configurator_disable_address_family_args object */
static gint32
bgp_configurator_disable_address_family_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableAddressFamilyArgs * this_object = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->peerIp != NULL)
          {
            g_free(this_object->peerIp);
            this_object->peerIp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->peerIp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_peerIp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast12;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast12, error)) < 0)
            return -1;
          xfer += ret;
          this_object->afi = (af_afi)ecast12;
          this_object->__isset_afi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->safi = (af_safi)ecast13;
          this_object->__isset_safi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_address_family_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableAddressFamilyArgs * this_object = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableAddressFamilyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "peerIp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->peerIp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afi", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->afi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "safi", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->safi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_disable_address_family_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  BgpConfiguratorDisableAddressFamilyArgs *self = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_PEER_IP:
      if (self->peerIp != NULL)
        g_free (self->peerIp);
      self->peerIp = g_value_dup_string (value);
      self->__isset_peerIp = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_AFI:
      self->afi = g_value_get_int (value);
      self->__isset_afi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_SAFI:
      self->safi = g_value_get_int (value);
      self->__isset_safi = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_disable_address_family_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  BgpConfiguratorDisableAddressFamilyArgs *self = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_PEER_IP:
      g_value_set_string (value, self->peerIp);
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_AFI:
      g_value_set_int (value, self->afi);
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_SAFI:
      g_value_set_int (value, self->safi);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_disable_address_family_args_instance_init (BgpConfiguratorDisableAddressFamilyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->peerIp = NULL;
  object->__isset_peerIp = FALSE;
  object->__isset_afi = FALSE;
  object->__isset_safi = FALSE;
}

static void 
bgp_configurator_disable_address_family_args_finalize (GObject *object)
{
  BgpConfiguratorDisableAddressFamilyArgs *tobject = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->peerIp != NULL)
  {
    g_free(tobject->peerIp);
    tobject->peerIp = NULL;
  }
}

static void
bgp_configurator_disable_address_family_args_class_init (BgpConfiguratorDisableAddressFamilyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_address_family_args_read;
  struct_class->write = bgp_configurator_disable_address_family_args_write;

  gobject_class->finalize = bgp_configurator_disable_address_family_args_finalize;
  gobject_class->get_property = bgp_configurator_disable_address_family_args_get_property;
  gobject_class->set_property = bgp_configurator_disable_address_family_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_PEER_IP,
     g_param_spec_string ("peerIp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_AFI,
     g_param_spec_int ("afi",
                       NULL,
                       NULL,
                       1,
                       3,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_ARGS_SAFI,
     g_param_spec_int ("safi",
                       NULL,
                       NULL,
                       4,
                       6,
                       4,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_disable_address_family_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableAddressFamilyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_address_family_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableAddressFamilyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_address_family_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableAddressFamilyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDisableAddressFamilyResultProperties
{
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT_0,
  PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT_SUCCESS
};

/* reads a bgp_configurator_disable_address_family_result object */
static gint32
bgp_configurator_disable_address_family_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableAddressFamilyResult * this_object = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_address_family_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableAddressFamilyResult * this_object = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableAddressFamilyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_disable_address_family_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  BgpConfiguratorDisableAddressFamilyResult *self = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_disable_address_family_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  BgpConfiguratorDisableAddressFamilyResult *self = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_disable_address_family_result_instance_init (BgpConfiguratorDisableAddressFamilyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_disable_address_family_result_finalize (GObject *object)
{
  BgpConfiguratorDisableAddressFamilyResult *tobject = BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_disable_address_family_result_class_init (BgpConfiguratorDisableAddressFamilyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_address_family_result_read;
  struct_class->write = bgp_configurator_disable_address_family_result_write;

  gobject_class->finalize = bgp_configurator_disable_address_family_result_finalize;
  gobject_class->get_property = bgp_configurator_disable_address_family_result_get_property;
  gobject_class->set_property = bgp_configurator_disable_address_family_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_ADDRESS_FAMILY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_disable_address_family_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableAddressFamilyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_address_family_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableAddressFamilyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_address_family_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableAddressFamilyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetLogConfigArgsProperties
{
  PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_0,
  PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_FILE_NAME,
  PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_LEVEL
};

/* reads a bgp_configurator_set_log_config_args object */
static gint32
bgp_configurator_set_log_config_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetLogConfigArgs * this_object = BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->logFileName != NULL)
          {
            g_free(this_object->logFileName);
            this_object->logFileName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->logFileName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_logFileName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->logLevel != NULL)
          {
            g_free(this_object->logLevel);
            this_object->logLevel = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->logLevel, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_logLevel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_log_config_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetLogConfigArgs * this_object = BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetLogConfigArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logFileName", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->logFileName, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logLevel", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->logLevel, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_log_config_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  BgpConfiguratorSetLogConfigArgs *self = BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_FILE_NAME:
      if (self->logFileName != NULL)
        g_free (self->logFileName);
      self->logFileName = g_value_dup_string (value);
      self->__isset_logFileName = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_LEVEL:
      if (self->logLevel != NULL)
        g_free (self->logLevel);
      self->logLevel = g_value_dup_string (value);
      self->__isset_logLevel = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_log_config_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  BgpConfiguratorSetLogConfigArgs *self = BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_FILE_NAME:
      g_value_set_string (value, self->logFileName);
      break;

    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_LEVEL:
      g_value_set_string (value, self->logLevel);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_log_config_args_instance_init (BgpConfiguratorSetLogConfigArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->logFileName = NULL;
  object->__isset_logFileName = FALSE;
  object->logLevel = NULL;
  object->__isset_logLevel = FALSE;
}

static void 
bgp_configurator_set_log_config_args_finalize (GObject *object)
{
  BgpConfiguratorSetLogConfigArgs *tobject = BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->logFileName != NULL)
  {
    g_free(tobject->logFileName);
    tobject->logFileName = NULL;
  }
  if (tobject->logLevel != NULL)
  {
    g_free(tobject->logLevel);
    tobject->logLevel = NULL;
  }
}

static void
bgp_configurator_set_log_config_args_class_init (BgpConfiguratorSetLogConfigArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_log_config_args_read;
  struct_class->write = bgp_configurator_set_log_config_args_write;

  gobject_class->finalize = bgp_configurator_set_log_config_args_finalize;
  gobject_class->get_property = bgp_configurator_set_log_config_args_get_property;
  gobject_class->set_property = bgp_configurator_set_log_config_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_FILE_NAME,
     g_param_spec_string ("logFileName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_ARGS_LOG_LEVEL,
     g_param_spec_string ("logLevel",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_configurator_set_log_config_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetLogConfigArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_log_config_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetLogConfigArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_log_config_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetLogConfigArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorSetLogConfigResultProperties
{
  PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT_0,
  PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT_SUCCESS
};

/* reads a bgp_configurator_set_log_config_result object */
static gint32
bgp_configurator_set_log_config_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorSetLogConfigResult * this_object = BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_set_log_config_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorSetLogConfigResult * this_object = BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorSetLogConfigResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_set_log_config_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorSetLogConfigResult *self = BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_set_log_config_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorSetLogConfigResult *self = BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_set_log_config_result_instance_init (BgpConfiguratorSetLogConfigResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_set_log_config_result_finalize (GObject *object)
{
  BgpConfiguratorSetLogConfigResult *tobject = BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_set_log_config_result_class_init (BgpConfiguratorSetLogConfigResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_set_log_config_result_read;
  struct_class->write = bgp_configurator_set_log_config_result_write;

  gobject_class->finalize = bgp_configurator_set_log_config_result_finalize;
  gobject_class->get_property = bgp_configurator_set_log_config_result_get_property;
  gobject_class->set_property = bgp_configurator_set_log_config_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_SET_LOG_CONFIG_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_set_log_config_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorSetLogConfigResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_set_log_config_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorSetLogConfigResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_set_log_config_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorSetLogConfigResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableGracefulRestartArgsProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS_0,
  PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS_STALEPATH_TIME
};

/* reads a bgp_configurator_enable_graceful_restart_args object */
static gint32
bgp_configurator_enable_graceful_restart_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableGracefulRestartArgs * this_object = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->stalepathTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stalepathTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_graceful_restart_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableGracefulRestartArgs * this_object = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableGracefulRestartArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stalepathTime", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->stalepathTime, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_graceful_restart_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  BgpConfiguratorEnableGracefulRestartArgs *self = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS_STALEPATH_TIME:
      self->stalepathTime = g_value_get_int (value);
      self->__isset_stalepathTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_graceful_restart_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  BgpConfiguratorEnableGracefulRestartArgs *self = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS_STALEPATH_TIME:
      g_value_set_int (value, self->stalepathTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_graceful_restart_args_instance_init (BgpConfiguratorEnableGracefulRestartArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stalepathTime = 0;
  object->__isset_stalepathTime = FALSE;
}

static void 
bgp_configurator_enable_graceful_restart_args_finalize (GObject *object)
{
  BgpConfiguratorEnableGracefulRestartArgs *tobject = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_enable_graceful_restart_args_class_init (BgpConfiguratorEnableGracefulRestartArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_graceful_restart_args_read;
  struct_class->write = bgp_configurator_enable_graceful_restart_args_write;

  gobject_class->finalize = bgp_configurator_enable_graceful_restart_args_finalize;
  gobject_class->get_property = bgp_configurator_enable_graceful_restart_args_get_property;
  gobject_class->set_property = bgp_configurator_enable_graceful_restart_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_ARGS_STALEPATH_TIME,
     g_param_spec_int ("stalepathTime",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_graceful_restart_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableGracefulRestartArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_graceful_restart_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableGracefulRestartArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_graceful_restart_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableGracefulRestartArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableGracefulRestartResultProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT_0,
  PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT_SUCCESS
};

/* reads a bgp_configurator_enable_graceful_restart_result object */
static gint32
bgp_configurator_enable_graceful_restart_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableGracefulRestartResult * this_object = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_graceful_restart_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableGracefulRestartResult * this_object = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableGracefulRestartResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_graceful_restart_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  BgpConfiguratorEnableGracefulRestartResult *self = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_graceful_restart_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  BgpConfiguratorEnableGracefulRestartResult *self = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_graceful_restart_result_instance_init (BgpConfiguratorEnableGracefulRestartResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_enable_graceful_restart_result_finalize (GObject *object)
{
  BgpConfiguratorEnableGracefulRestartResult *tobject = BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_enable_graceful_restart_result_class_init (BgpConfiguratorEnableGracefulRestartResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_graceful_restart_result_read;
  struct_class->write = bgp_configurator_enable_graceful_restart_result_write;

  gobject_class->finalize = bgp_configurator_enable_graceful_restart_result_finalize;
  gobject_class->get_property = bgp_configurator_enable_graceful_restart_result_get_property;
  gobject_class->set_property = bgp_configurator_enable_graceful_restart_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_GRACEFUL_RESTART_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_graceful_restart_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableGracefulRestartResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_graceful_restart_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableGracefulRestartResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_graceful_restart_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableGracefulRestartResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bgp_configurator_disable_graceful_restart_args object */
static gint32
bgp_configurator_disable_graceful_restart_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableGracefulRestartArgs * this_object = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_graceful_restart_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableGracefulRestartArgs * this_object = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableGracefulRestartArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
bgp_configurator_disable_graceful_restart_args_instance_init (BgpConfiguratorDisableGracefulRestartArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
bgp_configurator_disable_graceful_restart_args_finalize (GObject *object)
{
  BgpConfiguratorDisableGracefulRestartArgs *tobject = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_disable_graceful_restart_args_class_init (BgpConfiguratorDisableGracefulRestartArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_graceful_restart_args_read;
  struct_class->write = bgp_configurator_disable_graceful_restart_args_write;

  gobject_class->finalize = bgp_configurator_disable_graceful_restart_args_finalize;
}

GType
bgp_configurator_disable_graceful_restart_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableGracefulRestartArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_graceful_restart_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableGracefulRestartArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_graceful_restart_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableGracefulRestartArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDisableGracefulRestartResultProperties
{
  PROP_BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT_0,
  PROP_BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT_SUCCESS
};

/* reads a bgp_configurator_disable_graceful_restart_result object */
static gint32
bgp_configurator_disable_graceful_restart_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableGracefulRestartResult * this_object = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_graceful_restart_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableGracefulRestartResult * this_object = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableGracefulRestartResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_disable_graceful_restart_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  BgpConfiguratorDisableGracefulRestartResult *self = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_disable_graceful_restart_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  BgpConfiguratorDisableGracefulRestartResult *self = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_disable_graceful_restart_result_instance_init (BgpConfiguratorDisableGracefulRestartResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_disable_graceful_restart_result_finalize (GObject *object)
{
  BgpConfiguratorDisableGracefulRestartResult *tobject = BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_disable_graceful_restart_result_class_init (BgpConfiguratorDisableGracefulRestartResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_graceful_restart_result_read;
  struct_class->write = bgp_configurator_disable_graceful_restart_result_write;

  gobject_class->finalize = bgp_configurator_disable_graceful_restart_result_finalize;
  gobject_class->get_property = bgp_configurator_disable_graceful_restart_result_get_property;
  gobject_class->set_property = bgp_configurator_disable_graceful_restart_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_GRACEFUL_RESTART_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_disable_graceful_restart_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableGracefulRestartResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_graceful_restart_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableGracefulRestartResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_graceful_restart_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableGracefulRestartResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorGetRoutesArgsProperties
{
  PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_0,
  PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_P_TYPE,
  PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_OPTYPE,
  PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_WIN_SIZE
};

/* reads a bgp_configurator_get_routes_args object */
static gint32
bgp_configurator_get_routes_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorGetRoutesArgs * this_object = BGP_CONFIGURATOR_GET_ROUTES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast14;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast14, error)) < 0)
            return -1;
          xfer += ret;
          this_object->p_type = (protocol_type)ecast14;
          this_object->__isset_p_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->optype, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_optype = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->winSize, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_winSize = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_get_routes_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorGetRoutesArgs * this_object = BGP_CONFIGURATOR_GET_ROUTES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorGetRoutesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "p_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->p_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "optype", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->optype, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "winSize", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->winSize, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_get_routes_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorGetRoutesArgs *self = BGP_CONFIGURATOR_GET_ROUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_P_TYPE:
      self->p_type = g_value_get_int (value);
      self->__isset_p_type = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_OPTYPE:
      self->optype = g_value_get_int (value);
      self->__isset_optype = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_WIN_SIZE:
      self->winSize = g_value_get_int (value);
      self->__isset_winSize = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_get_routes_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorGetRoutesArgs *self = BGP_CONFIGURATOR_GET_ROUTES_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_P_TYPE:
      g_value_set_int (value, self->p_type);
      break;

    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_OPTYPE:
      g_value_set_int (value, self->optype);
      break;

    case PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_WIN_SIZE:
      g_value_set_int (value, self->winSize);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_get_routes_args_instance_init (BgpConfiguratorGetRoutesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_p_type = FALSE;
  object->optype = 0;
  object->__isset_optype = FALSE;
  object->winSize = 0;
  object->__isset_winSize = FALSE;
}

static void 
bgp_configurator_get_routes_args_finalize (GObject *object)
{
  BgpConfiguratorGetRoutesArgs *tobject = BGP_CONFIGURATOR_GET_ROUTES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_get_routes_args_class_init (BgpConfiguratorGetRoutesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_get_routes_args_read;
  struct_class->write = bgp_configurator_get_routes_args_write;

  gobject_class->finalize = bgp_configurator_get_routes_args_finalize;
  gobject_class->get_property = bgp_configurator_get_routes_args_get_property;
  gobject_class->set_property = bgp_configurator_get_routes_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_P_TYPE,
     g_param_spec_int ("p_type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_OPTYPE,
     g_param_spec_int ("optype",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_GET_ROUTES_ARGS_WIN_SIZE,
     g_param_spec_int ("winSize",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_get_routes_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorGetRoutesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_get_routes_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorGetRoutesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_get_routes_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorGetRoutesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorGetRoutesResultProperties
{
  PROP_BGP_CONFIGURATOR_GET_ROUTES_RESULT_0,
  PROP_BGP_CONFIGURATOR_GET_ROUTES_RESULT_SUCCESS
};

/* reads a bgp_configurator_get_routes_result object */
static gint32
bgp_configurator_get_routes_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorGetRoutesResult * this_object = BGP_CONFIGURATOR_GET_ROUTES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_get_routes_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorGetRoutesResult * this_object = BGP_CONFIGURATOR_GET_ROUTES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorGetRoutesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_get_routes_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorGetRoutesResult *self = BGP_CONFIGURATOR_GET_ROUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_GET_ROUTES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_get_routes_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorGetRoutesResult *self = BGP_CONFIGURATOR_GET_ROUTES_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_GET_ROUTES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_get_routes_result_instance_init (BgpConfiguratorGetRoutesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_ROUTES, NULL);
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_get_routes_result_finalize (GObject *object)
{
  BgpConfiguratorGetRoutesResult *tobject = BGP_CONFIGURATOR_GET_ROUTES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
bgp_configurator_get_routes_result_class_init (BgpConfiguratorGetRoutesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_get_routes_result_read;
  struct_class->write = bgp_configurator_get_routes_result_write;

  gobject_class->finalize = bgp_configurator_get_routes_result_finalize;
  gobject_class->get_property = bgp_configurator_get_routes_result_get_property;
  gobject_class->set_property = bgp_configurator_get_routes_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_GET_ROUTES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_ROUTES,
                         G_PARAM_READWRITE));
}

GType
bgp_configurator_get_routes_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorGetRoutesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_get_routes_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorGetRoutesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_get_routes_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorGetRoutesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableMultipathArgsProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_0,
  PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_AFI,
  PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_SAFI
};

/* reads a bgp_configurator_enable_multipath_args object */
static gint32
bgp_configurator_enable_multipath_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableMultipathArgs * this_object = BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast15;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast15, error)) < 0)
            return -1;
          xfer += ret;
          this_object->afi = (af_afi)ecast15;
          this_object->__isset_afi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->safi = (af_safi)ecast16;
          this_object->__isset_safi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_multipath_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableMultipathArgs * this_object = BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableMultipathArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afi", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->afi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "safi", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->safi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_multipath_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorEnableMultipathArgs *self = BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_AFI:
      self->afi = g_value_get_int (value);
      self->__isset_afi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_SAFI:
      self->safi = g_value_get_int (value);
      self->__isset_safi = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_multipath_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  BgpConfiguratorEnableMultipathArgs *self = BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_AFI:
      g_value_set_int (value, self->afi);
      break;

    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_SAFI:
      g_value_set_int (value, self->safi);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_multipath_args_instance_init (BgpConfiguratorEnableMultipathArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_afi = FALSE;
  object->__isset_safi = FALSE;
}

static void 
bgp_configurator_enable_multipath_args_finalize (GObject *object)
{
  BgpConfiguratorEnableMultipathArgs *tobject = BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_enable_multipath_args_class_init (BgpConfiguratorEnableMultipathArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_multipath_args_read;
  struct_class->write = bgp_configurator_enable_multipath_args_write;

  gobject_class->finalize = bgp_configurator_enable_multipath_args_finalize;
  gobject_class->get_property = bgp_configurator_enable_multipath_args_get_property;
  gobject_class->set_property = bgp_configurator_enable_multipath_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_AFI,
     g_param_spec_int ("afi",
                       NULL,
                       NULL,
                       1,
                       3,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_ARGS_SAFI,
     g_param_spec_int ("safi",
                       NULL,
                       NULL,
                       4,
                       6,
                       4,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_multipath_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableMultipathArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_multipath_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableMultipathArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_multipath_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableMultipathArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorEnableMultipathResultProperties
{
  PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT_0,
  PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT_SUCCESS
};

/* reads a bgp_configurator_enable_multipath_result object */
static gint32
bgp_configurator_enable_multipath_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorEnableMultipathResult * this_object = BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_enable_multipath_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorEnableMultipathResult * this_object = BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorEnableMultipathResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_enable_multipath_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  BgpConfiguratorEnableMultipathResult *self = BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_enable_multipath_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  BgpConfiguratorEnableMultipathResult *self = BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_enable_multipath_result_instance_init (BgpConfiguratorEnableMultipathResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_enable_multipath_result_finalize (GObject *object)
{
  BgpConfiguratorEnableMultipathResult *tobject = BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_enable_multipath_result_class_init (BgpConfiguratorEnableMultipathResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_enable_multipath_result_read;
  struct_class->write = bgp_configurator_enable_multipath_result_write;

  gobject_class->finalize = bgp_configurator_enable_multipath_result_finalize;
  gobject_class->get_property = bgp_configurator_enable_multipath_result_get_property;
  gobject_class->set_property = bgp_configurator_enable_multipath_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_ENABLE_MULTIPATH_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_enable_multipath_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorEnableMultipathResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_enable_multipath_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorEnableMultipathResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_enable_multipath_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorEnableMultipathResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDisableMultipathArgsProperties
{
  PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_0,
  PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_AFI,
  PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_SAFI
};

/* reads a bgp_configurator_disable_multipath_args object */
static gint32
bgp_configurator_disable_multipath_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableMultipathArgs * this_object = BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast17;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast17, error)) < 0)
            return -1;
          xfer += ret;
          this_object->afi = (af_afi)ecast17;
          this_object->__isset_afi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast18;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast18, error)) < 0)
            return -1;
          xfer += ret;
          this_object->safi = (af_safi)ecast18;
          this_object->__isset_safi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_multipath_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableMultipathArgs * this_object = BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableMultipathArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "afi", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->afi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "safi", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->safi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_disable_multipath_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorDisableMultipathArgs *self = BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_AFI:
      self->afi = g_value_get_int (value);
      self->__isset_afi = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_SAFI:
      self->safi = g_value_get_int (value);
      self->__isset_safi = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_disable_multipath_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  BgpConfiguratorDisableMultipathArgs *self = BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_AFI:
      g_value_set_int (value, self->afi);
      break;

    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_SAFI:
      g_value_set_int (value, self->safi);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_disable_multipath_args_instance_init (BgpConfiguratorDisableMultipathArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_afi = FALSE;
  object->__isset_safi = FALSE;
}

static void 
bgp_configurator_disable_multipath_args_finalize (GObject *object)
{
  BgpConfiguratorDisableMultipathArgs *tobject = BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_disable_multipath_args_class_init (BgpConfiguratorDisableMultipathArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_multipath_args_read;
  struct_class->write = bgp_configurator_disable_multipath_args_write;

  gobject_class->finalize = bgp_configurator_disable_multipath_args_finalize;
  gobject_class->get_property = bgp_configurator_disable_multipath_args_get_property;
  gobject_class->set_property = bgp_configurator_disable_multipath_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_AFI,
     g_param_spec_int ("afi",
                       NULL,
                       NULL,
                       1,
                       3,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_ARGS_SAFI,
     g_param_spec_int ("safi",
                       NULL,
                       NULL,
                       4,
                       6,
                       4,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_disable_multipath_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableMultipathArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_multipath_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableMultipathArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_multipath_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableMultipathArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorDisableMultipathResultProperties
{
  PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT_0,
  PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT_SUCCESS
};

/* reads a bgp_configurator_disable_multipath_result object */
static gint32
bgp_configurator_disable_multipath_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorDisableMultipathResult * this_object = BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_disable_multipath_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorDisableMultipathResult * this_object = BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorDisableMultipathResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_disable_multipath_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorDisableMultipathResult *self = BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_disable_multipath_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpConfiguratorDisableMultipathResult *self = BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_disable_multipath_result_instance_init (BgpConfiguratorDisableMultipathResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_disable_multipath_result_finalize (GObject *object)
{
  BgpConfiguratorDisableMultipathResult *tobject = BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_disable_multipath_result_class_init (BgpConfiguratorDisableMultipathResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_disable_multipath_result_read;
  struct_class->write = bgp_configurator_disable_multipath_result_write;

  gobject_class->finalize = bgp_configurator_disable_multipath_result_finalize;
  gobject_class->get_property = bgp_configurator_disable_multipath_result_get_property;
  gobject_class->set_property = bgp_configurator_disable_multipath_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_DISABLE_MULTIPATH_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_disable_multipath_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorDisableMultipathResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_disable_multipath_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorDisableMultipathResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_disable_multipath_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorDisableMultipathResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorMultipathsArgsProperties
{
  PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_0,
  PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_RD,
  PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_MAX_PATH
};

/* reads a bgp_configurator_multipaths_args object */
static gint32
bgp_configurator_multipaths_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorMultipathsArgs * this_object = BGP_CONFIGURATOR_MULTIPATHS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->maxPath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_maxPath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_multipaths_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorMultipathsArgs * this_object = BGP_CONFIGURATOR_MULTIPATHS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorMultipathsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "maxPath", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->maxPath, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_multipaths_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorMultipathsArgs *self = BGP_CONFIGURATOR_MULTIPATHS_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_MAX_PATH:
      self->maxPath = g_value_get_int (value);
      self->__isset_maxPath = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_multipaths_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  BgpConfiguratorMultipathsArgs *self = BGP_CONFIGURATOR_MULTIPATHS_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_MAX_PATH:
      g_value_set_int (value, self->maxPath);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_multipaths_args_instance_init (BgpConfiguratorMultipathsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->maxPath = 0;
  object->__isset_maxPath = FALSE;
}

static void 
bgp_configurator_multipaths_args_finalize (GObject *object)
{
  BgpConfiguratorMultipathsArgs *tobject = BGP_CONFIGURATOR_MULTIPATHS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
}

static void
bgp_configurator_multipaths_args_class_init (BgpConfiguratorMultipathsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_multipaths_args_read;
  struct_class->write = bgp_configurator_multipaths_args_write;

  gobject_class->finalize = bgp_configurator_multipaths_args_finalize;
  gobject_class->get_property = bgp_configurator_multipaths_args_get_property;
  gobject_class->set_property = bgp_configurator_multipaths_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_MULTIPATHS_ARGS_MAX_PATH,
     g_param_spec_int ("maxPath",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_multipaths_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorMultipathsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_multipaths_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorMultipathsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_multipaths_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorMultipathsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpConfiguratorMultipathsResultProperties
{
  PROP_BGP_CONFIGURATOR_MULTIPATHS_RESULT_0,
  PROP_BGP_CONFIGURATOR_MULTIPATHS_RESULT_SUCCESS
};

/* reads a bgp_configurator_multipaths_result object */
static gint32
bgp_configurator_multipaths_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpConfiguratorMultipathsResult * this_object = BGP_CONFIGURATOR_MULTIPATHS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_configurator_multipaths_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpConfiguratorMultipathsResult * this_object = BGP_CONFIGURATOR_MULTIPATHS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpConfiguratorMultipathsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_configurator_multipaths_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorMultipathsResult *self = BGP_CONFIGURATOR_MULTIPATHS_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_MULTIPATHS_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_configurator_multipaths_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  BgpConfiguratorMultipathsResult *self = BGP_CONFIGURATOR_MULTIPATHS_RESULT (object);

  switch (property_id)
  {
    case PROP_BGP_CONFIGURATOR_MULTIPATHS_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_configurator_multipaths_result_instance_init (BgpConfiguratorMultipathsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
bgp_configurator_multipaths_result_finalize (GObject *object)
{
  BgpConfiguratorMultipathsResult *tobject = BGP_CONFIGURATOR_MULTIPATHS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_configurator_multipaths_result_class_init (BgpConfiguratorMultipathsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_configurator_multipaths_result_read;
  struct_class->write = bgp_configurator_multipaths_result_write;

  gobject_class->finalize = bgp_configurator_multipaths_result_finalize;
  gobject_class->get_property = bgp_configurator_multipaths_result_get_property;
  gobject_class->set_property = bgp_configurator_multipaths_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_CONFIGURATOR_MULTIPATHS_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_configurator_multipaths_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpConfiguratorMultipathsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_configurator_multipaths_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpConfiguratorMultipathsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_configurator_multipaths_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpConfiguratorMultipathsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpUpdaterOnUpdatePushRouteArgsProperties
{
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_0,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_P_TYPE,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_RD,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIX,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIXLEN,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_NEXTHOP,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ETHTAG,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ESI,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_MACADDRESS,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L3LABEL,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L2LABEL,
  PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ROUTERMAC
};

/* reads a bgp_updater_on_update_push_route_args object */
static gint32
bgp_updater_on_update_push_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpUpdaterOnUpdatePushRouteArgs * this_object = BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast21;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast21, error)) < 0)
            return -1;
          xfer += ret;
          this_object->p_type = (protocol_type)ecast21;
          this_object->__isset_p_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->prefixlen, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefixlen = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->nexthop != NULL)
          {
            g_free(this_object->nexthop);
            this_object->nexthop = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nexthop, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nexthop = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ethtag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ethtag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->esi != NULL)
          {
            g_free(this_object->esi);
            this_object->esi = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->esi, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_esi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->macaddress != NULL)
          {
            g_free(this_object->macaddress);
            this_object->macaddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->macaddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_macaddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l3label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l3label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l2label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l2label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->routermac != NULL)
          {
            g_free(this_object->routermac);
            this_object->routermac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->routermac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_routermac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_updater_on_update_push_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpUpdaterOnUpdatePushRouteArgs * this_object = BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpUpdaterOnUpdatePushRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "p_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->p_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefixlen", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->prefixlen, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nexthop", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->nexthop, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ethtag", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ethtag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "esi", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->esi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "macaddress", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->macaddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l3label", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l3label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l2label", T_I32, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l2label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "routermac", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->routermac, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_updater_on_update_push_route_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  BgpUpdaterOnUpdatePushRouteArgs *self = BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_P_TYPE:
      self->p_type = g_value_get_int (value);
      self->__isset_p_type = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIXLEN:
      self->prefixlen = g_value_get_int (value);
      self->__isset_prefixlen = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_NEXTHOP:
      if (self->nexthop != NULL)
        g_free (self->nexthop);
      self->nexthop = g_value_dup_string (value);
      self->__isset_nexthop = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ETHTAG:
      self->ethtag = g_value_get_int64 (value);
      self->__isset_ethtag = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ESI:
      if (self->esi != NULL)
        g_free (self->esi);
      self->esi = g_value_dup_string (value);
      self->__isset_esi = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_MACADDRESS:
      if (self->macaddress != NULL)
        g_free (self->macaddress);
      self->macaddress = g_value_dup_string (value);
      self->__isset_macaddress = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L3LABEL:
      self->l3label = g_value_get_int (value);
      self->__isset_l3label = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L2LABEL:
      self->l2label = g_value_get_int (value);
      self->__isset_l2label = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ROUTERMAC:
      if (self->routermac != NULL)
        g_free (self->routermac);
      self->routermac = g_value_dup_string (value);
      self->__isset_routermac = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_updater_on_update_push_route_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  BgpUpdaterOnUpdatePushRouteArgs *self = BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_P_TYPE:
      g_value_set_int (value, self->p_type);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIXLEN:
      g_value_set_int (value, self->prefixlen);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_NEXTHOP:
      g_value_set_string (value, self->nexthop);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ETHTAG:
      g_value_set_int64 (value, self->ethtag);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ESI:
      g_value_set_string (value, self->esi);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_MACADDRESS:
      g_value_set_string (value, self->macaddress);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L3LABEL:
      g_value_set_int (value, self->l3label);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L2LABEL:
      g_value_set_int (value, self->l2label);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ROUTERMAC:
      g_value_set_string (value, self->routermac);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_updater_on_update_push_route_args_instance_init (BgpUpdaterOnUpdatePushRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_p_type = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->prefixlen = 0;
  object->__isset_prefixlen = FALSE;
  object->nexthop = NULL;
  object->__isset_nexthop = FALSE;
  object->ethtag = 0;
  object->__isset_ethtag = FALSE;
  object->esi = NULL;
  object->__isset_esi = FALSE;
  object->macaddress = NULL;
  object->__isset_macaddress = FALSE;
  object->l3label = 0;
  object->__isset_l3label = FALSE;
  object->l2label = 0;
  object->__isset_l2label = FALSE;
  object->routermac = NULL;
  object->__isset_routermac = FALSE;
}

static void 
bgp_updater_on_update_push_route_args_finalize (GObject *object)
{
  BgpUpdaterOnUpdatePushRouteArgs *tobject = BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
  if (tobject->nexthop != NULL)
  {
    g_free(tobject->nexthop);
    tobject->nexthop = NULL;
  }
  if (tobject->esi != NULL)
  {
    g_free(tobject->esi);
    tobject->esi = NULL;
  }
  if (tobject->macaddress != NULL)
  {
    g_free(tobject->macaddress);
    tobject->macaddress = NULL;
  }
  if (tobject->routermac != NULL)
  {
    g_free(tobject->routermac);
    tobject->routermac = NULL;
  }
}

static void
bgp_updater_on_update_push_route_args_class_init (BgpUpdaterOnUpdatePushRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_updater_on_update_push_route_args_read;
  struct_class->write = bgp_updater_on_update_push_route_args_write;

  gobject_class->finalize = bgp_updater_on_update_push_route_args_finalize;
  gobject_class->get_property = bgp_updater_on_update_push_route_args_get_property;
  gobject_class->set_property = bgp_updater_on_update_push_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_P_TYPE,
     g_param_spec_int ("p_type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_PREFIXLEN,
     g_param_spec_int ("prefixlen",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_NEXTHOP,
     g_param_spec_string ("nexthop",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ETHTAG,
     g_param_spec_int64 ("ethtag",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ESI,
     g_param_spec_string ("esi",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_MACADDRESS,
     g_param_spec_string ("macaddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L3LABEL,
     g_param_spec_int ("l3label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_L2LABEL,
     g_param_spec_int ("l2label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_PUSH_ROUTE_ARGS_ROUTERMAC,
     g_param_spec_string ("routermac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
bgp_updater_on_update_push_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpUpdaterOnUpdatePushRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_updater_on_update_push_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpUpdaterOnUpdatePushRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_updater_on_update_push_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpUpdaterOnUpdatePushRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpUpdaterOnUpdateWithdrawRouteArgsProperties
{
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_0,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_P_TYPE,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_RD,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIX,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIXLEN,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_NEXTHOP,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ETHTAG,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ESI,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_MACADDRESS,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L3LABEL,
  PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L2LABEL
};

/* reads a bgp_updater_on_update_withdraw_route_args object */
static gint32
bgp_updater_on_update_withdraw_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpUpdaterOnUpdateWithdrawRouteArgs * this_object = BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast22;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast22, error)) < 0)
            return -1;
          xfer += ret;
          this_object->p_type = (protocol_type)ecast22;
          this_object->__isset_p_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->rd != NULL)
          {
            g_free(this_object->rd);
            this_object->rd = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->rd, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rd = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->prefixlen, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefixlen = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->nexthop != NULL)
          {
            g_free(this_object->nexthop);
            this_object->nexthop = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->nexthop, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_nexthop = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ethtag, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ethtag = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->esi != NULL)
          {
            g_free(this_object->esi);
            this_object->esi = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->esi, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_esi = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->macaddress != NULL)
          {
            g_free(this_object->macaddress);
            this_object->macaddress = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->macaddress, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_macaddress = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l3label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l3label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->l2label, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_l2label = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_updater_on_update_withdraw_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpUpdaterOnUpdateWithdrawRouteArgs * this_object = BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpUpdaterOnUpdateWithdrawRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "p_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->p_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rd", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->rd, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefixlen", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->prefixlen, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nexthop", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->nexthop, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ethtag", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ethtag, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "esi", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->esi, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "macaddress", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->macaddress, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l3label", T_I32, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l3label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "l2label", T_I32, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->l2label, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_updater_on_update_withdraw_route_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  BgpUpdaterOnUpdateWithdrawRouteArgs *self = BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_P_TYPE:
      self->p_type = g_value_get_int (value);
      self->__isset_p_type = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_RD:
      if (self->rd != NULL)
        g_free (self->rd);
      self->rd = g_value_dup_string (value);
      self->__isset_rd = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIXLEN:
      self->prefixlen = g_value_get_int (value);
      self->__isset_prefixlen = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_NEXTHOP:
      if (self->nexthop != NULL)
        g_free (self->nexthop);
      self->nexthop = g_value_dup_string (value);
      self->__isset_nexthop = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ETHTAG:
      self->ethtag = g_value_get_int64 (value);
      self->__isset_ethtag = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ESI:
      if (self->esi != NULL)
        g_free (self->esi);
      self->esi = g_value_dup_string (value);
      self->__isset_esi = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_MACADDRESS:
      if (self->macaddress != NULL)
        g_free (self->macaddress);
      self->macaddress = g_value_dup_string (value);
      self->__isset_macaddress = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L3LABEL:
      self->l3label = g_value_get_int (value);
      self->__isset_l3label = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L2LABEL:
      self->l2label = g_value_get_int (value);
      self->__isset_l2label = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_updater_on_update_withdraw_route_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  BgpUpdaterOnUpdateWithdrawRouteArgs *self = BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_P_TYPE:
      g_value_set_int (value, self->p_type);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_RD:
      g_value_set_string (value, self->rd);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIXLEN:
      g_value_set_int (value, self->prefixlen);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_NEXTHOP:
      g_value_set_string (value, self->nexthop);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ETHTAG:
      g_value_set_int64 (value, self->ethtag);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ESI:
      g_value_set_string (value, self->esi);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_MACADDRESS:
      g_value_set_string (value, self->macaddress);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L3LABEL:
      g_value_set_int (value, self->l3label);
      break;

    case PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L2LABEL:
      g_value_set_int (value, self->l2label);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_updater_on_update_withdraw_route_args_instance_init (BgpUpdaterOnUpdateWithdrawRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_p_type = FALSE;
  object->rd = NULL;
  object->__isset_rd = FALSE;
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->prefixlen = 0;
  object->__isset_prefixlen = FALSE;
  object->nexthop = NULL;
  object->__isset_nexthop = FALSE;
  object->ethtag = 0;
  object->__isset_ethtag = FALSE;
  object->esi = NULL;
  object->__isset_esi = FALSE;
  object->macaddress = NULL;
  object->__isset_macaddress = FALSE;
  object->l3label = 0;
  object->__isset_l3label = FALSE;
  object->l2label = 0;
  object->__isset_l2label = FALSE;
}

static void 
bgp_updater_on_update_withdraw_route_args_finalize (GObject *object)
{
  BgpUpdaterOnUpdateWithdrawRouteArgs *tobject = BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->rd != NULL)
  {
    g_free(tobject->rd);
    tobject->rd = NULL;
  }
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
  if (tobject->nexthop != NULL)
  {
    g_free(tobject->nexthop);
    tobject->nexthop = NULL;
  }
  if (tobject->esi != NULL)
  {
    g_free(tobject->esi);
    tobject->esi = NULL;
  }
  if (tobject->macaddress != NULL)
  {
    g_free(tobject->macaddress);
    tobject->macaddress = NULL;
  }
}

static void
bgp_updater_on_update_withdraw_route_args_class_init (BgpUpdaterOnUpdateWithdrawRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_updater_on_update_withdraw_route_args_read;
  struct_class->write = bgp_updater_on_update_withdraw_route_args_write;

  gobject_class->finalize = bgp_updater_on_update_withdraw_route_args_finalize;
  gobject_class->get_property = bgp_updater_on_update_withdraw_route_args_get_property;
  gobject_class->set_property = bgp_updater_on_update_withdraw_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_P_TYPE,
     g_param_spec_int ("p_type",
                       NULL,
                       NULL,
                       1,
                       4,
                       1,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_RD,
     g_param_spec_string ("rd",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_PREFIXLEN,
     g_param_spec_int ("prefixlen",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_NEXTHOP,
     g_param_spec_string ("nexthop",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ETHTAG,
     g_param_spec_int64 ("ethtag",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_ESI,
     g_param_spec_string ("esi",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_MACADDRESS,
     g_param_spec_string ("macaddress",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L3LABEL,
     g_param_spec_int ("l3label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_UPDATE_WITHDRAW_ROUTE_ARGS_L2LABEL,
     g_param_spec_int ("l2label",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_updater_on_update_withdraw_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpUpdaterOnUpdateWithdrawRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_updater_on_update_withdraw_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpUpdaterOnUpdateWithdrawRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_updater_on_update_withdraw_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpUpdaterOnUpdateWithdrawRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bgp_updater_on_start_config_resync_notification_args object */
static gint32
bgp_updater_on_start_config_resync_notification_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpUpdaterOnStartConfigResyncNotificationArgs * this_object = BGP_UPDATER_ON_START_CONFIG_RESYNC_NOTIFICATION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_updater_on_start_config_resync_notification_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpUpdaterOnStartConfigResyncNotificationArgs * this_object = BGP_UPDATER_ON_START_CONFIG_RESYNC_NOTIFICATION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpUpdaterOnStartConfigResyncNotificationArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
bgp_updater_on_start_config_resync_notification_args_instance_init (BgpUpdaterOnStartConfigResyncNotificationArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
bgp_updater_on_start_config_resync_notification_args_finalize (GObject *object)
{
  BgpUpdaterOnStartConfigResyncNotificationArgs *tobject = BGP_UPDATER_ON_START_CONFIG_RESYNC_NOTIFICATION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bgp_updater_on_start_config_resync_notification_args_class_init (BgpUpdaterOnStartConfigResyncNotificationArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_updater_on_start_config_resync_notification_args_read;
  struct_class->write = bgp_updater_on_start_config_resync_notification_args_write;

  gobject_class->finalize = bgp_updater_on_start_config_resync_notification_args_finalize;
}

GType
bgp_updater_on_start_config_resync_notification_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpUpdaterOnStartConfigResyncNotificationArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_updater_on_start_config_resync_notification_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpUpdaterOnStartConfigResyncNotificationArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_updater_on_start_config_resync_notification_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpUpdaterOnStartConfigResyncNotificationArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BgpUpdaterOnNotificationSendEventArgsProperties
{
  PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_0,
  PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_PREFIX,
  PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_CODE,
  PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_SUBCODE
};

/* reads a bgp_updater_on_notification_send_event_args object */
static gint32
bgp_updater_on_notification_send_event_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BgpUpdaterOnNotificationSendEventArgs * this_object = BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->prefix != NULL)
          {
            g_free(this_object->prefix);
            this_object->prefix = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->errCode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errCode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->errSubcode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_errSubcode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bgp_updater_on_notification_send_event_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BgpUpdaterOnNotificationSendEventArgs * this_object = BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BgpUpdaterOnNotificationSendEventArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->prefix, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errCode", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->errCode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "errSubcode", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->errSubcode, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bgp_updater_on_notification_send_event_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  BgpUpdaterOnNotificationSendEventArgs *self = BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_PREFIX:
      if (self->prefix != NULL)
        g_free (self->prefix);
      self->prefix = g_value_dup_string (value);
      self->__isset_prefix = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_CODE:
      self->errCode = g_value_get_int (value);
      self->__isset_errCode = TRUE;
      break;

    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_SUBCODE:
      self->errSubcode = g_value_get_int (value);
      self->__isset_errSubcode = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bgp_updater_on_notification_send_event_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  BgpUpdaterOnNotificationSendEventArgs *self = BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS (object);

  switch (property_id)
  {
    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_PREFIX:
      g_value_set_string (value, self->prefix);
      break;

    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_CODE:
      g_value_set_int (value, self->errCode);
      break;

    case PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_SUBCODE:
      g_value_set_int (value, self->errSubcode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bgp_updater_on_notification_send_event_args_instance_init (BgpUpdaterOnNotificationSendEventArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->prefix = NULL;
  object->__isset_prefix = FALSE;
  object->errCode = 0;
  object->__isset_errCode = FALSE;
  object->errSubcode = 0;
  object->__isset_errSubcode = FALSE;
}

static void 
bgp_updater_on_notification_send_event_args_finalize (GObject *object)
{
  BgpUpdaterOnNotificationSendEventArgs *tobject = BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->prefix != NULL)
  {
    g_free(tobject->prefix);
    tobject->prefix = NULL;
  }
}

static void
bgp_updater_on_notification_send_event_args_class_init (BgpUpdaterOnNotificationSendEventArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bgp_updater_on_notification_send_event_args_read;
  struct_class->write = bgp_updater_on_notification_send_event_args_write;

  gobject_class->finalize = bgp_updater_on_notification_send_event_args_finalize;
  gobject_class->get_property = bgp_updater_on_notification_send_event_args_get_property;
  gobject_class->set_property = bgp_updater_on_notification_send_event_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_PREFIX,
     g_param_spec_string ("prefix",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_CODE,
     g_param_spec_int ("errCode",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BGP_UPDATER_ON_NOTIFICATION_SEND_EVENT_ARGS_ERR_SUBCODE,
     g_param_spec_int ("errSubcode",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
bgp_updater_on_notification_send_event_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BgpUpdaterOnNotificationSendEventArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bgp_updater_on_notification_send_event_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BgpUpdaterOnNotificationSendEventArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) bgp_updater_on_notification_send_event_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BgpUpdaterOnNotificationSendEventArgsType",
                                   &type_info, 0);
  }

  return type;
}

