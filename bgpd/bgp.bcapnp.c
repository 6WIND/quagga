/*
 * AUTOGENERATED FILE - DO NOT EDIT
 * derived from GPLv2+ sources
 */
#include <stdbool.h>
#include "c-capnproto/capn.h"
#include "bgp.bcapnp.h"

static const capn_text capn_val0 = {0, ""};


#include "zebra.h"
#include "bgpd.h"

afi_t qcapn_AfiSafiKey_get_afi(capn_ptr p)
{
    capn_resolve(&p);
    return capn_read8(p, 0);
}


safi_t qcapn_AfiSafiKey_get_safi(capn_ptr p)
{
    capn_resolve(&p);
    return capn_read8(p, 1);
}


afi_t qcapn_AfiKey_get_afi(capn_ptr p)
{
    capn_resolve(&p);
    return capn_read8(p, 0);
}

void qcapn_VRFTableIter_set(struct tbliter_v4 *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: prefix */
    }
}

void qcapn_BGP_set(struct bgp *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: as */
    }
    {
      /* MISSING: name */
    }
    {
      struct in_addr router_id_static;
      
    {
        capn_ptr tmp_p = capn_getp(p, 1, 1);
        router_id_static.s_addr = htonl(capn_read32(tmp_p, 0));
    }
      bgp_router_id_static_set(s, router_id_static);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 0));
      if (flags) bgp_flag_set(s, BGP_FLAG_ALWAYS_COMPARE_MED);
	else bgp_flag_unset(s, BGP_FLAG_ALWAYS_COMPARE_MED);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 1));
      if (flags) bgp_flag_set(s, BGP_FLAG_DETERMINISTIC_MED);
	else bgp_flag_unset(s, BGP_FLAG_DETERMINISTIC_MED);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 2));
      if (flags) bgp_flag_set(s, BGP_FLAG_MED_MISSING_AS_WORST);
	else bgp_flag_unset(s, BGP_FLAG_MED_MISSING_AS_WORST);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 3));
      if (flags) bgp_flag_set(s, BGP_FLAG_MED_CONFED);
	else bgp_flag_unset(s, BGP_FLAG_MED_CONFED);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 4));
      if (flags) bgp_flag_set(s, BGP_FLAG_NO_DEFAULT_IPV4);
	else bgp_flag_unset(s, BGP_FLAG_NO_DEFAULT_IPV4);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 5));
      if (flags) bgp_flag_set(s, BGP_FLAG_NO_CLIENT_TO_CLIENT);
	else bgp_flag_unset(s, BGP_FLAG_NO_CLIENT_TO_CLIENT);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 6));
      if (flags) bgp_flag_set(s, BGP_FLAG_ENFORCE_FIRST_AS);
	else bgp_flag_unset(s, BGP_FLAG_ENFORCE_FIRST_AS);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 4) & (1 << 7));
      if (flags) bgp_flag_set(s, BGP_FLAG_COMPARE_ROUTER_ID);
	else bgp_flag_unset(s, BGP_FLAG_COMPARE_ROUTER_ID);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 0));
      if (flags) bgp_flag_set(s, BGP_FLAG_ASPATH_IGNORE);
	else bgp_flag_unset(s, BGP_FLAG_ASPATH_IGNORE);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 1));
      if (flags) bgp_flag_set(s, BGP_FLAG_IMPORT_CHECK);
	else bgp_flag_unset(s, BGP_FLAG_IMPORT_CHECK);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 2));
      if (flags) bgp_flag_set(s, BGP_FLAG_NO_FAST_EXT_FAILOVER);
	else bgp_flag_unset(s, BGP_FLAG_NO_FAST_EXT_FAILOVER);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 3));
      if (flags) bgp_flag_set(s, BGP_FLAG_LOG_NEIGHBOR_CHANGES);
	else bgp_flag_unset(s, BGP_FLAG_LOG_NEIGHBOR_CHANGES);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 4));
      if (flags) bgp_flag_set(s, BGP_FLAG_GRACEFUL_RESTART);
	else bgp_flag_unset(s, BGP_FLAG_GRACEFUL_RESTART);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 5));
      if (flags) bgp_flag_set(s, BGP_FLAG_ASPATH_CONFED);
	else bgp_flag_unset(s, BGP_FLAG_ASPATH_CONFED);
      
    }
    {
      u_int16_t flags;
      flags = !!(capn_read8(p, 5) & (1 << 6));
      if (flags) bgp_flag_set(s, BGP_FLAG_ASPATH_MULTIPATH_RELAX);
	else bgp_flag_unset(s, BGP_FLAG_ASPATH_MULTIPATH_RELAX);
      
    }
    {
      u_int32_t default_local_pref;
      default_local_pref = capn_read32(p, 12);
      if (default_local_pref) { bgp_default_local_preference_set(s, default_local_pref); } else { bgp_default_local_preference_unset(s); }
      
    }
    {
      u_int32_t keepalive;
      u_int32_t holdtime;
      keepalive = capn_read32(p, 20);
      holdtime = capn_read32(p, 16);
      if (keepalive || holdtime) { bgp_timers_set(s, keepalive, holdtime); } else { bgp_timers_unset(s); }
      
      
    }
    {
      /* MISSING: restart_time */
    }
    {
      const char * notify_zmq_url;
      { capn_text tp = capn_get_text(p, 2, capn_val0); notify_zmq_url = tp.str; }
      bgp_notify_zmq_url_set(s, notify_zmq_url);
      
    }
    s->distance_ebgp = capn_read8(p, 6);
    s->distance_ibgp = capn_read8(p, 7);
    s->distance_local = capn_read8(p, 8);
    s->stalepath_time = capn_read32(p, 28);
}


as_t qcapn_BGP_get_as(capn_ptr p)
{
    capn_resolve(&p);
    return capn_read32(p, 0);
}


void qcapn_BGPAfiSafi_read(struct bgp *s, capn_ptr p, afi_t afi, safi_t safi)
{
    capn_resolve(&p);
    { bool tmp;
      tmp = !!(capn_read8(p, 0) & (1 << 0));
      if (tmp) s->af_flags[afi][safi] |=  BGP_CONFIG_DAMPENING;
      else     s->af_flags[afi][safi] &= ~BGP_CONFIG_DAMPENING;
    }
}



void qcapn_BGPAfiSafi_write(const struct bgp *s, capn_ptr p, afi_t afi, safi_t safi)
{
    capn_resolve(&p);
    capn_write1(p, 0, !!(s->af_flags[afi][safi] & BGP_CONFIG_DAMPENING));
}



void qcapn_BGPAfiSafi_set(struct bgp *s, capn_ptr p, afi_t afi, safi_t safi)
{
    capn_resolve(&p);
    {
      /* MISSING: af_flags */
    }
}


capn_ptr qcapn_new_BGPAfiSafi(struct capn_segment *s)
{
    return capn_new_struct(s, 8, 0);
}


void qcapn_BGPPeer_set(struct peer *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: as */
    }
    {
      /* MISSING: host */
    }
    {
      const char * desc;
      { capn_text tp = capn_get_text(p, 1, capn_val0); desc = tp.str; }
      if (desc) { peer_description_set(s, desc); } else { peer_description_unset(s); }
      
    }
    {
      unsigned port;
      port = capn_read16(p, 4);
      if (port) { peer_port_set(s, port); } else { peer_port_unset(s); }
      
    }
    {
      u_int32_t weight;
      weight = capn_read32(p, 8);
      if (weight) { peer_weight_set(s, weight); } else { peer_weight_unset(s); }
      
    }
    {
      u_int32_t keepalive;
      u_int32_t holdtime;
      keepalive = capn_read32(p, 16);
      holdtime = capn_read32(p, 12);
      if (keepalive || holdtime) { peer_timers_set(s, keepalive, holdtime); } else { peer_timers_unset(s); }
      
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 0));
      if (flags) peer_flag_set(s, PEER_FLAG_PASSIVE);
	else peer_flag_unset(s, PEER_FLAG_PASSIVE);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 1));
      if (flags) peer_flag_set(s, PEER_FLAG_SHUTDOWN);
	else peer_flag_unset(s, PEER_FLAG_SHUTDOWN);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 2));
      if (flags) peer_flag_set(s, PEER_FLAG_DONT_CAPABILITY);
	else peer_flag_unset(s, PEER_FLAG_DONT_CAPABILITY);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 3));
      if (flags) peer_flag_set(s, PEER_FLAG_OVERRIDE_CAPABILITY);
	else peer_flag_unset(s, PEER_FLAG_OVERRIDE_CAPABILITY);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 4));
      if (flags) peer_flag_set(s, PEER_FLAG_STRICT_CAP_MATCH);
	else peer_flag_unset(s, PEER_FLAG_STRICT_CAP_MATCH);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 5));
      if (flags) peer_flag_set(s, PEER_FLAG_DYNAMIC_CAPABILITY);
	else peer_flag_unset(s, PEER_FLAG_DYNAMIC_CAPABILITY);
      
    }
    {
      u_int32_t flags;
      flags = !!(capn_read8(p, 6) & (1 << 6));
      if (flags) peer_flag_set(s, PEER_FLAG_DISABLE_CONNECTED_CHECK);
	else peer_flag_unset(s, PEER_FLAG_DISABLE_CONNECTED_CHECK);
      
    }
    {
      int ttl;
      ttl = capn_read32(p, 20);
      if (ttl) { peer_ebgp_multihop_set(s, ttl); } else { peer_ebgp_multihop_unset(s); }
      
    }
    {
      const char * update_source = NULL;
      int len;
      capn_text tp = capn_get_text(p, 2, capn_val0);
      update_source = tp.str;
      len = tp.len;
      if (update_source && len != 0)
        {
          union sockunion *su;

          su = sockunion_str2su (update_source);
          if (su)
            s->update_source = su;
          else
            s->update_if = strdup(update_source);
        }
      else
        {
          s->update_source = NULL;
          s->update_if = NULL;
        }
    }
}


as_t qcapn_BGPPeer_get_as(capn_ptr p)
{
    capn_resolve(&p);
    return capn_read32(p, 0);
}


const char * qcapn_BGPPeer_get_host(capn_ptr p)
{
    capn_resolve(&p);
    capn_text tp = capn_get_text(p, 0, capn_val0);; return tp.str;
}

void qcapn_BGPPeerAfiSafi_set(struct peer *s, capn_ptr p, afi_t afi, safi_t safi)
{
    capn_resolve(&p);
    {
      u_char afc;
      afc = !!(capn_read8(p, 0) & (1 << 0));
      peer_afc_set(s, afi, safi, afc);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 1));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_SEND_COMMUNITY);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_SEND_COMMUNITY);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 2));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 3));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_NEXTHOP_SELF);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_NEXTHOP_SELF);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 4));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_REFLECTOR_CLIENT);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_REFLECTOR_CLIENT);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 5));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_RSERVER_CLIENT);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_RSERVER_CLIENT);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 6));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_SOFT_RECONFIG);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_SOFT_RECONFIG);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 0) & (1 << 7));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_AS_PATH_UNCHANGED);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_AS_PATH_UNCHANGED);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 0));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_NEXTHOP_UNCHANGED);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_NEXTHOP_UNCHANGED);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 1));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_MED_UNCHANGED);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_MED_UNCHANGED);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 2));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_DEFAULT_ORIGINATE);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_DEFAULT_ORIGINATE);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 3));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_REMOVE_PRIVATE_AS);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_REMOVE_PRIVATE_AS);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 4));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_ALLOWAS_IN);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_ALLOWAS_IN);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 5));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_ORF_PREFIX_SM);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_ORF_PREFIX_SM);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 6));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_ORF_PREFIX_RM);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_ORF_PREFIX_RM);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 1) & (1 << 7));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_MAX_PREFIX);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_MAX_PREFIX);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 2) & (1 << 0));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_MAX_PREFIX_WARNING);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_MAX_PREFIX_WARNING);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 2) & (1 << 1));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED);
      
    }
    {
      u_int32_t af_flags;
      af_flags = !!(capn_read8(p, 2) & (1 << 2));
      if (af_flags) peer_af_flag_set(s, afi, safi, PEER_FLAG_NEXTHOP_SELF_ALL);
	else peer_af_flag_unset(s, afi, safi, PEER_FLAG_NEXTHOP_SELF_ALL);
      
    }
    {
      char allowas_in;
      allowas_in = capn_read8(p, 3);
      if (allowas_in) { peer_allowas_in_set(s, afi, safi, allowas_in); } else { peer_allowas_in_unset(s, afi, safi); }
      
    }
}



void qcapn_BGPVRF_read(struct bgp_vrf *s, capn_ptr p)
{
    capn_resolve(&p);
    *(uint64_t *)s->outbound_rd.val = capn_read64(p, 0);
    s->outbound_rd.family = AF_UNSPEC;
    s->outbound_rd.prefixlen = 64;
    
    {
        capn_ptr tmp_p = capn_getp(p, 0, 1);
        capn_list64 listptr = { .p = capn_getp(tmp_p, 0, 1) };
        size_t listsize = capn_len(listptr);
        uint64_t buf[listsize];
        capn_getv64(listptr, 0, buf, listsize);
        if (s->rt_import)
            ecommunity_unintern(&s->rt_import);
        s->rt_import = ecommunity_parse ((uint8_t *)buf, listsize * 8);
    }
    
    {
        capn_ptr tmp_p = capn_getp(p, 1, 1);
        capn_list64 listptr = { .p = capn_getp(tmp_p, 0, 1) };
        size_t listsize = capn_len(listptr);
        uint64_t buf[listsize];
        capn_getv64(listptr, 0, buf, listsize);
        if (s->rt_export)
            ecommunity_unintern(&s->rt_export);
        s->rt_export = ecommunity_parse ((uint8_t *)buf, listsize * 8);
    }
}

void qcapn_BGPVRF_set(struct bgp_vrf *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: outbound_rd */
    }
    {
      struct ecommunity * rt_import;
      
    {
        capn_ptr tmp_p = capn_getp(p, 0, 1);
        capn_list64 listptr = { .p = capn_getp(tmp_p, 0, 1) };
        size_t listsize = capn_len(listptr);
        uint64_t buf[listsize];
        capn_getv64(listptr, 0, buf, listsize);
        rt_import = ecommunity_parse ((uint8_t *)buf, listsize * 8);
    }
      bgp_vrf_rt_import_set(s, rt_import);
      
        ecommunity_unintern(&rt_import);
    }
    {
      struct ecommunity * rt_export;
      
    {
        capn_ptr tmp_p = capn_getp(p, 1, 1);
        capn_list64 listptr = { .p = capn_getp(tmp_p, 0, 1) };
        size_t listsize = capn_len(listptr);
        uint64_t buf[listsize];
        capn_getv64(listptr, 0, buf, listsize);
        rt_export = ecommunity_parse ((uint8_t *)buf, listsize * 8);
    }
      bgp_vrf_rt_export_set(s, rt_export);
      
        ecommunity_unintern(&rt_export);
    }
}


struct prefix_rd qcapn_BGPVRF_get_outbound_rd(capn_ptr p)
{
    capn_resolve(&p);
    struct prefix_rd tp;
    tp.family = AF_UNSPEC;
    tp.prefixlen = 64;
    *(uint64_t *)tp.val = capn_read64(p, 0); return tp;
}

void qcapn_BGPVRFRoute_set(struct bgp_api_route *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: prefix */
    }
    {
      /* MISSING: nexthop */
    }
    {
      /* MISSING: label */
    }
}


void qcapn_BGPEventVRFRoute_write(const struct bgp_event_vrf *s, capn_ptr p)
{
    capn_resolve(&p);
    capn_write8(p, 0, s->announce);
    capn_write64(p, 8, *(uint64_t *)s->outbound_rd.val);
    
    {
        capn_ptr tempptr = capn_new_struct(p.seg, 8, 0);
        capn_write8(tempptr, 4, s->prefix.prefixlen);
        capn_write32(tempptr, 0, ntohl(s->prefix.prefix.s_addr));
        capn_setp(p, 0, tempptr);
    }
    
    {
        capn_ptr tempptr = capn_new_struct(p.seg, 8, 0);
        capn_write32(tempptr, 0, ntohl(s->nexthop.s_addr));
        capn_setp(p, 1, tempptr);
    }
    capn_write32(p, 4, s->label);
}



void qcapn_BGPEventVRFRoute_set(struct bgp_event_vrf *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: announce */
    }
    {
      /* MISSING: outbound_rd */
    }
    {
      /* MISSING: prefix */
    }
    {
      /* MISSING: nexthop */
    }
    {
      /* MISSING: label */
    }
}


capn_ptr qcapn_new_BGPEventVRFRoute(struct capn_segment *s)
{
    return capn_new_struct(s, 16, 2);
}


void qcapn_BGPEventShut_write(const struct bgp_event_shut *s, capn_ptr p)
{
    capn_resolve(&p);
    
    {
        capn_ptr tempptr = capn_new_struct(p.seg, 8, 0);
        capn_write32(tempptr, 0, ntohl(s->peer.s_addr));
        capn_setp(p, 0, tempptr);
    }
    capn_write8(p, 0, s->type);
    capn_write8(p, 1, s->subtype);
}



void qcapn_BGPEventShut_set(struct bgp_event_shut *s, capn_ptr p)
{
    capn_resolve(&p);
    {
      /* MISSING: peer */
    }
    {
      /* MISSING: type */
    }
    {
      /* MISSING: subtype */
    }
}


capn_ptr qcapn_new_BGPEventShut(struct capn_segment *s)
{
    return capn_new_struct(s, 8, 1);
}

